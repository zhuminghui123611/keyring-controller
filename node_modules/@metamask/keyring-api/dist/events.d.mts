import type { Infer } from "@metamask/superstruct";
/**
 * Supported keyring events.
 */
export declare enum KeyringEvent {
    AccountCreated = "notify:accountCreated",
    AccountUpdated = "notify:accountUpdated",
    AccountDeleted = "notify:accountDeleted",
    RequestApproved = "notify:requestApproved",
    RequestRejected = "notify:requestRejected",
    AccountBalancesUpdated = "notify:accountBalancesUpdated",
    AccountAssetListUpdated = "notify:accountAssetListUpdated",
    AccountTransactionsUpdated = "notify:accountTransactionsUpdated"
}
export declare const AccountCreatedEventStruct: import("@metamask/superstruct").Struct<{
    method: "notify:accountCreated";
    params: {
        account: {
            type: "eip155:eoa" | "eip155:erc4337" | "bip122:p2pkh" | "bip122:p2sh" | "bip122:p2wpkh" | "bip122:p2tr" | "solana:data-account" | "tron:eoa" | "any:account";
            id: string;
            options: Record<string, import("@metamask/utils").Json> & {
                entropy?: {
                    type: "mnemonic";
                    id: string;
                    derivationPath: string;
                    groupIndex: number;
                } | {
                    type: "private-key";
                };
                exportable?: boolean;
            };
            address: string;
            scopes: `${string}:${string}`[];
            methods: string[];
        };
        metamask?: {
            correlationId: string;
        };
        accountNameSuggestion?: string;
        displayConfirmation?: boolean;
        displayAccountNameSuggestion?: boolean;
    };
}, {
    method: import("@metamask/superstruct").Struct<"notify:accountCreated", "notify:accountCreated">;
    params: import("@metamask/superstruct").Struct<{
        account: {
            type: "eip155:eoa" | "eip155:erc4337" | "bip122:p2pkh" | "bip122:p2sh" | "bip122:p2wpkh" | "bip122:p2tr" | "solana:data-account" | "tron:eoa" | "any:account";
            id: string;
            options: Record<string, import("@metamask/utils").Json> & {
                entropy?: {
                    type: "mnemonic";
                    id: string;
                    derivationPath: string;
                    groupIndex: number;
                } | {
                    type: "private-key";
                };
                exportable?: boolean;
            };
            address: string;
            scopes: `${string}:${string}`[];
            methods: string[];
        };
        metamask?: {
            correlationId: string;
        };
        accountNameSuggestion?: string;
        displayConfirmation?: boolean;
        displayAccountNameSuggestion?: boolean;
    }, {
        metamask: import("@metamask/superstruct").Struct<import("@metamask/keyring-utils").ExactOptionalTag | {
            correlationId: string;
        }, {
            correlationId: import("@metamask/superstruct").Struct<string, null>;
        }>;
        /**
         * New account object.
         */
        account: import("@metamask/superstruct").Struct<{
            type: "eip155:eoa" | "eip155:erc4337" | "bip122:p2pkh" | "bip122:p2sh" | "bip122:p2wpkh" | "bip122:p2tr" | "solana:data-account" | "tron:eoa" | "any:account";
            id: string;
            options: Record<string, import("@metamask/utils").Json> & {
                entropy?: {
                    type: "mnemonic";
                    id: string;
                    derivationPath: string;
                    groupIndex: number;
                } | {
                    type: "private-key";
                };
                exportable?: boolean;
            };
            address: string;
            scopes: `${string}:${string}`[];
            methods: string[];
        }, {
            id: import("@metamask/superstruct").Struct<string, null>;
            type: import("@metamask/superstruct").Struct<"eip155:eoa" | "eip155:erc4337" | "bip122:p2pkh" | "bip122:p2sh" | "bip122:p2wpkh" | "bip122:p2tr" | "solana:data-account" | "tron:eoa" | "any:account", {
                "eip155:eoa": "eip155:eoa";
                "eip155:erc4337": "eip155:erc4337";
                "bip122:p2pkh": "bip122:p2pkh";
                "bip122:p2sh": "bip122:p2sh";
                "bip122:p2wpkh": "bip122:p2wpkh";
                "bip122:p2tr": "bip122:p2tr";
                "solana:data-account": "solana:data-account";
                "tron:eoa": "tron:eoa";
                "any:account": "any:account";
            }>;
            address: import("@metamask/superstruct").Struct<string, null>;
            scopes: import("@metamask/superstruct").Struct<`${string}:${string}`[], import("@metamask/superstruct").Struct<`${string}:${string}`, null>>;
            options: import("@metamask/superstruct").Struct<Record<string, import("@metamask/utils").Json> & {
                entropy?: {
                    type: "mnemonic";
                    id: string;
                    derivationPath: string;
                    groupIndex: number;
                } | {
                    type: "private-key";
                };
                exportable?: boolean;
            }, null>;
            methods: import("@metamask/superstruct").Struct<string[], import("@metamask/superstruct").Struct<string, null>>;
        }>;
        /**
         * Account name suggestion provided to the MetaMask client.
         *
         * The keyring can suggest a name for the account, but it's up to the
         * client to decide whether to use it. The keyring won't be informed if the
         * client decides to use a different name.
         */
        accountNameSuggestion: import("@metamask/superstruct").Struct<string | import("@metamask/keyring-utils").ExactOptionalTag, null>;
        /**
         * Instructs MetaMask to display the add account confirmation dialog in the UI.
         *
         * **Note:** This is not guaranteed to be honored by the MetaMask client.
         */
        displayConfirmation: import("@metamask/superstruct").Struct<boolean | import("@metamask/keyring-utils").ExactOptionalTag, null>;
        /**
         * Instructs MetaMask to display the name confirmation dialog in the UI.
         * Otherwise, the account will be added with the suggested name, if it's not
         * already in use; if it is, a suffix will be appended to the name to make it
         * unique.
         *
         * **Note:** This is not guaranteed to be honored by the MetaMask client.
         */
        displayAccountNameSuggestion: import("@metamask/superstruct").Struct<boolean | import("@metamask/keyring-utils").ExactOptionalTag, null>;
    }>;
}>;
export type AccountCreatedEvent = Infer<typeof AccountCreatedEventStruct>;
export type AccountCreatedEventPayload = AccountCreatedEvent['params'];
export declare const AccountUpdatedEventStruct: import("@metamask/superstruct").Struct<{
    method: "notify:accountUpdated";
    params: {
        account: {
            type: "eip155:eoa" | "eip155:erc4337" | "bip122:p2pkh" | "bip122:p2sh" | "bip122:p2wpkh" | "bip122:p2tr" | "solana:data-account" | "tron:eoa" | "any:account";
            id: string;
            options: Record<string, import("@metamask/utils").Json> & {
                entropy?: {
                    type: "mnemonic";
                    id: string;
                    derivationPath: string;
                    groupIndex: number;
                } | {
                    type: "private-key";
                };
                exportable?: boolean;
            };
            address: string;
            scopes: `${string}:${string}`[];
            methods: string[];
        };
    };
}, {
    method: import("@metamask/superstruct").Struct<"notify:accountUpdated", "notify:accountUpdated">;
    params: import("@metamask/superstruct").Struct<{
        account: {
            type: "eip155:eoa" | "eip155:erc4337" | "bip122:p2pkh" | "bip122:p2sh" | "bip122:p2wpkh" | "bip122:p2tr" | "solana:data-account" | "tron:eoa" | "any:account";
            id: string;
            options: Record<string, import("@metamask/utils").Json> & {
                entropy?: {
                    type: "mnemonic";
                    id: string;
                    derivationPath: string;
                    groupIndex: number;
                } | {
                    type: "private-key";
                };
                exportable?: boolean;
            };
            address: string;
            scopes: `${string}:${string}`[];
            methods: string[];
        };
    }, {
        /**
         * Updated account object.
         */
        account: import("@metamask/superstruct").Struct<{
            type: "eip155:eoa" | "eip155:erc4337" | "bip122:p2pkh" | "bip122:p2sh" | "bip122:p2wpkh" | "bip122:p2tr" | "solana:data-account" | "tron:eoa" | "any:account";
            id: string;
            options: Record<string, import("@metamask/utils").Json> & {
                entropy?: {
                    type: "mnemonic";
                    id: string;
                    derivationPath: string;
                    groupIndex: number;
                } | {
                    type: "private-key";
                };
                exportable?: boolean;
            };
            address: string;
            scopes: `${string}:${string}`[];
            methods: string[];
        }, {
            id: import("@metamask/superstruct").Struct<string, null>;
            type: import("@metamask/superstruct").Struct<"eip155:eoa" | "eip155:erc4337" | "bip122:p2pkh" | "bip122:p2sh" | "bip122:p2wpkh" | "bip122:p2tr" | "solana:data-account" | "tron:eoa" | "any:account", {
                "eip155:eoa": "eip155:eoa";
                "eip155:erc4337": "eip155:erc4337";
                "bip122:p2pkh": "bip122:p2pkh";
                "bip122:p2sh": "bip122:p2sh";
                "bip122:p2wpkh": "bip122:p2wpkh";
                "bip122:p2tr": "bip122:p2tr";
                "solana:data-account": "solana:data-account";
                "tron:eoa": "tron:eoa";
                "any:account": "any:account";
            }>;
            address: import("@metamask/superstruct").Struct<string, null>;
            scopes: import("@metamask/superstruct").Struct<`${string}:${string}`[], import("@metamask/superstruct").Struct<`${string}:${string}`, null>>;
            options: import("@metamask/superstruct").Struct<Record<string, import("@metamask/utils").Json> & {
                entropy?: {
                    type: "mnemonic";
                    id: string;
                    derivationPath: string;
                    groupIndex: number;
                } | {
                    type: "private-key";
                };
                exportable?: boolean;
            }, null>;
            methods: import("@metamask/superstruct").Struct<string[], import("@metamask/superstruct").Struct<string, null>>;
        }>;
    }>;
}>;
export type AccountUpdatedEvent = Infer<typeof AccountUpdatedEventStruct>;
export type AccountUpdatedEventPayload = AccountUpdatedEvent['params'];
export declare const AccountDeletedEventStruct: import("@metamask/superstruct").Struct<{
    method: "notify:accountDeleted";
    params: {
        id: string;
    };
}, {
    method: import("@metamask/superstruct").Struct<"notify:accountDeleted", "notify:accountDeleted">;
    params: import("@metamask/superstruct").Struct<{
        id: string;
    }, {
        /**
         * Deleted account ID.
         */
        id: import("@metamask/superstruct").Struct<string, null>;
    }>;
}>;
export type AccountDeletedEvent = Infer<typeof AccountDeletedEventStruct>;
export type AccountDeletedEventPayload = AccountDeletedEvent['params'];
export declare const RequestApprovedEventStruct: import("@metamask/superstruct").Struct<{
    method: "notify:requestApproved";
    params: {
        result: import("@metamask/utils").Json;
        id: string;
    };
}, {
    method: import("@metamask/superstruct").Struct<"notify:requestApproved", "notify:requestApproved">;
    params: import("@metamask/superstruct").Struct<{
        result: import("@metamask/utils").Json;
        id: string;
    }, {
        /**
         * Request ID.
         */
        id: import("@metamask/superstruct").Struct<string, null>;
        /**
         * Request result.
         */
        result: import("@metamask/superstruct").Struct<import("@metamask/utils").Json, unknown>;
    }>;
}>;
export type RequestApprovedEvent = Infer<typeof RequestApprovedEventStruct>;
export type RequestApprovedEventPayload = RequestApprovedEvent['params'];
export declare const RequestRejectedEventStruct: import("@metamask/superstruct").Struct<{
    method: "notify:requestRejected";
    params: {
        id: string;
    };
}, {
    method: import("@metamask/superstruct").Struct<"notify:requestRejected", "notify:requestRejected">;
    params: import("@metamask/superstruct").Struct<{
        id: string;
    }, {
        /**
         * Request ID.
         */
        id: import("@metamask/superstruct").Struct<string, null>;
    }>;
}>;
export type RequestRejectedEvent = Infer<typeof RequestRejectedEventStruct>;
export type RequestRejectedEventPayload = RequestRejectedEvent['params'];
/**
 * Event emitted when the balances of an account are updated.
 *
 * Only changes are reported.
 *
 * The Snap can choose to emit this event for multiple accounts at once.
 */
export declare const AccountBalancesUpdatedEventStruct: import("@metamask/superstruct").Struct<{
    method: "notify:accountBalancesUpdated";
    params: {
        balances: Record<string, Record<`${string}:${string}/${string}:${string}`, {
            unit: string;
            amount: string;
        }>>;
    };
}, {
    method: import("@metamask/superstruct").Struct<"notify:accountBalancesUpdated", "notify:accountBalancesUpdated">;
    params: import("@metamask/superstruct").Struct<{
        balances: Record<string, Record<`${string}:${string}/${string}:${string}`, {
            unit: string;
            amount: string;
        }>>;
    }, {
        /**
         * Balances updates of accounts owned by the Snap.
         */
        balances: import("@metamask/superstruct").Struct<Record<string, Record<`${string}:${string}/${string}:${string}`, {
            unit: string;
            amount: string;
        }>>, null>;
    }>;
}>;
export type AccountBalancesUpdatedEvent = Infer<typeof AccountBalancesUpdatedEventStruct>;
export type AccountBalancesUpdatedEventPayload = AccountBalancesUpdatedEvent['params'];
/**
 * Event emitted when the transactions of an account are updated (added or
 * changed).
 *
 * Only changes are reported.
 *
 * The Snap can choose to emit this event for multiple accounts at once.
 */
export declare const AccountTransactionsUpdatedEventStruct: import("@metamask/superstruct").Struct<{
    method: "notify:accountTransactionsUpdated";
    params: {
        transactions: Record<string, {
            type: "unknown" | "send" | "receive" | "swap" | "bridge:send" | "bridge:receive";
            id: string;
            from: {
                address: string;
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                } | null;
            }[];
            events: {
                status: "submitted" | "unconfirmed" | "confirmed" | "failed";
                timestamp: number | null;
            }[];
            chain: `${string}:${string}`;
            status: "submitted" | "unconfirmed" | "confirmed" | "failed";
            account: string;
            timestamp: number | null;
            to: {
                address: string;
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                } | null;
            }[];
            fees: {
                type: "base" | "priority";
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                };
            }[];
        }[]>;
    };
}, {
    method: import("@metamask/superstruct").Struct<"notify:accountTransactionsUpdated", "notify:accountTransactionsUpdated">;
    params: import("@metamask/superstruct").Struct<{
        transactions: Record<string, {
            type: "unknown" | "send" | "receive" | "swap" | "bridge:send" | "bridge:receive";
            id: string;
            from: {
                address: string;
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                } | null;
            }[];
            events: {
                status: "submitted" | "unconfirmed" | "confirmed" | "failed";
                timestamp: number | null;
            }[];
            chain: `${string}:${string}`;
            status: "submitted" | "unconfirmed" | "confirmed" | "failed";
            account: string;
            timestamp: number | null;
            to: {
                address: string;
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                } | null;
            }[];
            fees: {
                type: "base" | "priority";
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                };
            }[];
        }[]>;
    }, {
        /**
         * Transactions updates of accounts owned by the Snap.
         */
        transactions: import("@metamask/superstruct").Struct<Record<string, {
            type: "unknown" | "send" | "receive" | "swap" | "bridge:send" | "bridge:receive";
            id: string;
            from: {
                address: string;
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                } | null;
            }[];
            events: {
                status: "submitted" | "unconfirmed" | "confirmed" | "failed";
                timestamp: number | null;
            }[];
            chain: `${string}:${string}`;
            status: "submitted" | "unconfirmed" | "confirmed" | "failed";
            account: string;
            timestamp: number | null;
            to: {
                address: string;
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                } | null;
            }[];
            fees: {
                type: "base" | "priority";
                asset: {
                    unit: string;
                    type: `${string}:${string}/${string}:${string}`;
                    amount: string;
                    fungible: true;
                } | {
                    id: `${string}:${string}/${string}:${string}/${string}`;
                    fungible: false;
                };
            }[];
        }[]>, null>;
    }>;
}>;
export type AccountTransactionsUpdatedEvent = Infer<typeof AccountTransactionsUpdatedEventStruct>;
export type AccountTransactionsUpdatedEventPayload = AccountTransactionsUpdatedEvent['params'];
/**
 * Event emitted when the assets of an account are updated.
 *
 * Only changes are reported.
 *
 * The Snap can choose to emit this event for multiple accounts at once.
 */
export declare const AccountAssetListUpdatedEventStruct: import("@metamask/superstruct").Struct<{
    method: "notify:accountAssetListUpdated";
    params: {
        assets: Record<string, {
            added: (`${string}:${string}/${string}:${string}` | `${string}:${string}/${string}:${string}/${string}`)[];
            removed: (`${string}:${string}/${string}:${string}` | `${string}:${string}/${string}:${string}/${string}`)[];
        }>;
    };
}, {
    method: import("@metamask/superstruct").Struct<"notify:accountAssetListUpdated", "notify:accountAssetListUpdated">;
    params: import("@metamask/superstruct").Struct<{
        assets: Record<string, {
            added: (`${string}:${string}/${string}:${string}` | `${string}:${string}/${string}:${string}/${string}`)[];
            removed: (`${string}:${string}/${string}:${string}` | `${string}:${string}/${string}:${string}/${string}`)[];
        }>;
    }, {
        /**
         * Asset list update of accounts owned by the Snap.
         */
        assets: import("@metamask/superstruct").Struct<Record<string, {
            added: (`${string}:${string}/${string}:${string}` | `${string}:${string}/${string}:${string}/${string}`)[];
            removed: (`${string}:${string}/${string}:${string}` | `${string}:${string}/${string}:${string}/${string}`)[];
        }>, null>;
    }>;
}>;
export type AccountAssetListUpdatedEvent = Infer<typeof AccountAssetListUpdatedEventStruct>;
export type AccountAssetListUpdatedEventPayload = AccountAssetListUpdatedEvent['params'];
/**
 * Keyring events.
 */
type KeyringEvents = AccountCreatedEvent | AccountUpdatedEvent | AccountDeletedEvent | AccountAssetListUpdatedEvent | AccountBalancesUpdatedEvent | AccountTransactionsUpdatedEvent | RequestApprovedEvent | RequestRejectedEvent;
/**
 * Extract the payload for a given `KeyringEvent` event.
 */
export type KeyringEventPayload<Event extends KeyringEvent> = Extract<KeyringEvents, {
    method: `${Event}`;
}>['params'];
export {};
//# sourceMappingURL=events.d.mts.map