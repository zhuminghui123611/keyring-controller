"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BtcP2trAccountStruct = exports.BtcP2wpkhAccountStruct = exports.BtcP2shAccountStruct = exports.BtcP2pkhAccountStruct = exports.BtcMethod = exports.BtcP2trAddressStruct = exports.BtcP2wpkhAddressStruct = exports.BtcP2shAddressStruct = exports.BtcP2pkhAddressStruct = void 0;
const keyring_utils_1 = require("@metamask/keyring-utils");
const superstruct_1 = require("@metamask/superstruct");
const bitcoin_address_validation_1 = require("bitcoin-address-validation");
const api_1 = require("../api/index.cjs");
const validateAddress = (address, type) => {
    try {
        const addressInfo = (0, bitcoin_address_validation_1.getAddressInfo)(address);
        if (addressInfo.type === type) {
            return true;
        }
        return new Error(`Invalid ${type} address`);
    }
    catch (error) {
        return new Error(`Failed to decode ${type} address: ${error.message}`);
    }
};
exports.BtcP2pkhAddressStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'BtcP2pkhAddressStruct', (address) => {
    return validateAddress(address, bitcoin_address_validation_1.AddressType.p2pkh);
});
exports.BtcP2shAddressStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'BtcP2shAddressStruct', (address) => {
    return validateAddress(address, bitcoin_address_validation_1.AddressType.p2sh);
});
exports.BtcP2wpkhAddressStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'BtcP2wpkhAddressStruct', (address) => {
    return validateAddress(address, bitcoin_address_validation_1.AddressType.p2wpkh);
});
exports.BtcP2trAddressStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'BtcP2trAddressStruct', (address) => {
    return validateAddress(address, bitcoin_address_validation_1.AddressType.p2tr);
});
/**
 * Supported Bitcoin methods.
 */
var BtcMethod;
(function (BtcMethod) {
    BtcMethod["SignPsbt"] = "signPsbt";
    BtcMethod["ComputeFee"] = "computeFee";
    BtcMethod["FillPsbt"] = "fillPsbt";
    BtcMethod["BroadcastPsbt"] = "broadcastPsbt";
    BtcMethod["SendTransfer"] = "sendTransfer";
    BtcMethod["GetUtxo"] = "getUtxo";
    BtcMethod["ListUtxos"] = "listUtxos";
    BtcMethod["PublicDescriptor"] = "publicDescriptor";
    BtcMethod["SignMessage"] = "signMessage";
})(BtcMethod || (exports.BtcMethod = BtcMethod = {}));
const BtcAccountStruct = (0, keyring_utils_1.object)({
    ...api_1.KeyringAccountStruct.schema,
    /**
     * Account supported scopes (CAIP-2 chain ID).
     */
    scopes: (0, superstruct_1.nonempty)((0, superstruct_1.array)(api_1.CaipChainIdStruct)),
    /**
     * Account supported methods.
     */
    methods: (0, superstruct_1.array)((0, superstruct_1.enums)(Object.values(BtcMethod))),
});
exports.BtcP2pkhAccountStruct = (0, keyring_utils_1.object)({
    ...BtcAccountStruct.schema,
    /**
     * Account P2PKH address.
     */
    address: exports.BtcP2pkhAddressStruct,
    /**
     * Account type.
     */
    type: (0, superstruct_1.literal)(`${api_1.BtcAccountType.P2pkh}`),
});
exports.BtcP2shAccountStruct = (0, keyring_utils_1.object)({
    ...BtcAccountStruct.schema,
    /**
     * Account P2SH address.
     */
    address: exports.BtcP2shAddressStruct,
    /**
     * Account type.
     */
    type: (0, superstruct_1.literal)(`${api_1.BtcAccountType.P2sh}`),
});
exports.BtcP2wpkhAccountStruct = (0, keyring_utils_1.object)({
    ...BtcAccountStruct.schema,
    /**
     * Account P2WPKH address.
     */
    address: exports.BtcP2wpkhAddressStruct,
    /**
     * Account type.
     */
    type: (0, superstruct_1.literal)(`${api_1.BtcAccountType.P2wpkh}`),
});
exports.BtcP2trAccountStruct = (0, keyring_utils_1.object)({
    ...BtcAccountStruct.schema,
    /**
     * Account P2TR address.
     */
    address: exports.BtcP2trAddressStruct,
    /**
     * Account type.
     */
    type: (0, superstruct_1.literal)(`${api_1.BtcAccountType.P2tr}`),
});
//# sourceMappingURL=types.cjs.map