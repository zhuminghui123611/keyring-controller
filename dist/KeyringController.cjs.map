{"version":3,"file":"KeyringController.cjs","sourceRoot":"","sources":["../src/KeyringController.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,2CAAiE;AAMjE,+DAA2D;AAC3D,6EAA+D;AAC/D,6DAAqD;AACrD,yDAAmE;AACnE,sFAAyD;AAWzD,2CAWyB;AACzB,6CAAoC;AAEpC,uEAAoE;AAEpE,mCAAiC;AACjC,sHAAsH;AACtH,+BAA4B;AAE5B,+CAAqD;AAOrD,MAAM,IAAI,GAAG,mBAAmB,CAAC;AAEjC;;GAEG;AACH,IAAY,YASX;AATD,WAAY,YAAY;IACtB,0CAA0B,CAAA;IAC1B,kCAAkB,CAAA;IAClB,gDAAgC,CAAA;IAChC,0CAA0B,CAAA;IAC1B,0CAA0B,CAAA;IAC1B,0CAA0B,CAAA;IAC1B,4CAA4B,CAAA;IAC5B,qCAAqB,CAAA;AACvB,CAAC,EATW,YAAY,4BAAZ,YAAY,QASvB;AAED;;;;;;GAMG;AACI,MAAM,gBAAgB,GAAG,CAAC,WAAmB,EAAW,EAAE;IAC/D,OAAO,WAAW,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;AAC3C,CAAC,CAAC;AAFW,QAAA,gBAAgB,oBAE3B;AA6NF;;GAEG;AACH,IAAY,qBAGX;AAHD,WAAY,qBAAqB;IAC/B,kDAAyB,CAAA;IACzB,sCAAa,CAAA;AACf,CAAC,EAHW,qBAAqB,qCAArB,qBAAqB,QAGhC;AAED;;;;GAIG;AACH,IAAY,oBAIX;AAJD,WAAY,oBAAoB;IAC9B,iCAAS,CAAA;IACT,iCAAS,CAAA;IACT,iCAAS,CAAA;AACX,CAAC,EAJW,oBAAoB,oCAApB,oBAAoB,QAI/B;AA+ID;;;;;;;GAOG;AACH,SAAgB,qBAAqB,CAAC,kBAAgC;IACpE,MAAM,OAAO,GAAG,GAAG,EAAE,CAAC,IAAI,kBAAkB,EAAE,CAAC;IAE/C,OAAO,CAAC,IAAI,GAAG,kBAAkB,CAAC,IAAI,CAAC;IAEvC,OAAO,OAAO,CAAC;AACjB,CAAC;AAND,sDAMC;AAED,MAAM,sBAAsB,GAAG;IAC7B,uFAAuF;IACvF,gDAAgD;IAChD,qBAAqB,CAAC,4BAAa,CAAC;IACpC,gDAAgD;IAChD,qBAAqB,CAAC,0BAAS,CAAC;CACjC,CAAC;AAEK,MAAM,sBAAsB,GAAG,GAA2B,EAAE;IACjE,OAAO;QACL,UAAU,EAAE,KAAK;QACjB,QAAQ,EAAE,EAAE;KACb,CAAC;AACJ,CAAC,CAAC;AALW,QAAA,sBAAsB,0BAKjC;AAEF;;;;;;GAMG;AACH,SAAS,2BAA2B,CAClC,OAAmB;IAEnB,IACE,CAAC,CACC,IAAA,mBAAW,EAAC,OAAO,EAAE,UAAU,CAAC,IAAI,OAAO,CAAC,QAAQ,YAAY,UAAU,CAC3E,EACD;QACA,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC,CAAC;KAC1D;AACH,CAAC;AAED;;;;;;GAMG;AACH,SAAS,8BAA8B,CACrC,SAAoD;IAEpD,IACE,CAAC,CACC,WAAW,IAAI,SAAS;QACxB,OAAO,SAAS,CAAC,SAAS,KAAK,UAAU;QACzC,gBAAgB,IAAI,SAAS;QAC7B,OAAO,SAAS,CAAC,cAAc,KAAK,UAAU;QAC9C,gBAAgB,IAAI,SAAS;QAC7B,OAAO,SAAS,CAAC,cAAc,KAAK,UAAU,CAC/C,EACD;QACA,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,8BAA8B,CAAC,CAAC;KACxE;AACH,CAAC;AAED;;;;;GAKG;AACH,SAAS,qBAAqB,CAAC,QAAiB;IAC9C,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QAChC,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,iBAAiB,CAAC,CAAC;KAC3D;IAED,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;QACjC,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,oBAAoB,CAAC,CAAC;KAC9D;AACH,CAAC;AAED;;;;;GAKG;AACH,SAAS,wBAAwB,CAC/B,aAAiC;IAEjC,IAAI,CAAC,aAAa,EAAE;QAClB,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,mBAAmB,CAAC,CAAC;KAC7D;AACH,CAAC;AAED;;;;;GAKG;AACH,SAAS,yBAAyB,CAChC,KAAc;IAEd,OAAO,CACL,OAAO,KAAK,KAAK,QAAQ;QACzB,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;QACpB,KAAK,CAAC,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,IAAA,mBAAW,EAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAC9D,CAAC;AACJ,CAAC;AAED;;;;;;;;;GASG;AACH,KAAK,UAAU,iBAAiB,CAAC,EAC/B,OAAO,EACP,QAAQ,GAIT;IACC,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,WAAW,EAAE,CAAC;IAE7C,OAAO;QACL,IAAI,EAAE,OAAO,CAAC,IAAI;QAClB,yEAAyE;QACzE,wEAAwE;QACxE,QAAQ,EAAE,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAa;QAC7C,QAAQ;KACT,CAAC;AACJ,CAAC;AAED;;;;;GAKG;AACH,SAAS,YAAY,CAAC,OAAe;IACnC,0EAA0E;IAC1E,qEAAqE;IACrE,OAAO;IACL,yDAAyD;IACzD,IAAA,yBAAiB,EAAC,OAAO,CAAC,WAAW,EAAE,CAAC;QACxC,kEAAkE;QAClE,IAAA,yBAAiB,EAAC,OAAc,CAAC,CAClC,CAAC;AACJ,CAAC;AAED;;;;;GAKG;AACH,SAAS,SAAS,CAAC,OAAe;IAChC,sEAAsE;IACtE,2EAA2E;IAC3E,sDAAsD;IACtD,wEAAwE;IACxE,uBAAuB;IACvB,OAAO,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAA,wBAAY,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC;AACjE,CAAC;AAED;;;;;;;;GAQG;AACH,MAAa,iBAAkB,SAAQ,gCAItC;IAqBC;;;;;;;;;OASG;IACH,YAAY,OAAiC;QAC3C,MAAM,EACJ,SAAS,GAAG,cAAc,EAC1B,eAAe,EACf,SAAS,EACT,KAAK,GACN,GAAG,OAAO,CAAC;QAEZ,KAAK,CAAC;YACJ,IAAI;YACJ,QAAQ,EAAE;gBACR,KAAK,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE;gBAC1C,UAAU,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,EAAE;gBAC/C,QAAQ,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE;gBAC9C,aAAa,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE;gBACnD,cAAc,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE;aACrD;YACD,SAAS;YACT,KAAK,EAAE;gBACL,GAAG,IAAA,8BAAsB,GAAE;gBAC3B,GAAG,KAAK;aACT;SACF,CAAC,CAAC;;QApDI,sDAA4B,IAAI,mBAAK,EAAE,EAAC;QAExC,iDAAuB,IAAI,mBAAK,EAAE,EAAC;QAEnC,qDAAqD;QAErD,+CAAsD;QAEtD,wDAA6B;QAEtC,8CAAgE;QAEhE,yDAA0C;QAE1C,8CAAmB;QAEnB,4DAEU;QAoCR,uBAAA,IAAI,sCAAoB,eAAe;YACrC,CAAC,CAAC,eAAe,CAAC,MAAM,CAAC,sBAAsB,CAAC;YAChD,CAAC,CAAC,sBAAsB,MAAA,CAAC;QAE3B,uBAAA,IAAI,gCAAc,SAAS,MAAA,CAAC;QAC5B,uBAAA,IAAI,+BAAa,EAAE,MAAA,CAAC;QACpB,uBAAA,IAAI,0CAAwB,EAAE,MAAA,CAAC;QAE/B,6DAA6D;QAC7D,6DAA6D;QAC7D,uBAAA,IAAI,yCAAuB,OAAO,CAAC,OAAO,CAAC,kBAAkB,CAAC,MAAA,CAAC;QAC/D,IAAI,uBAAA,IAAI,6CAAoB,EAAE;YAC5B,8BAA8B,CAAC,SAAS,CAAC,CAAC;SAC3C;QAED,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,CAA2B,CAAC;IAClC,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,aAAa,CAAC,YAAqB;QACvC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,MAAM,cAAc,GAAG,IAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC,CAAC,CAEjD,CAAC;YACd,IAAI,CAAC,cAAc,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;aACxC;YACD,MAAM,WAAW,GAAG,MAAM,cAAc,CAAC,WAAW,EAAE,CAAC;YAEvD,IAAI,YAAY,IAAI,WAAW,CAAC,MAAM,KAAK,YAAY,EAAE;gBACvD,IAAI,YAAY,GAAG,WAAW,CAAC,MAAM,EAAE;oBACrC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;iBAC5C;gBACD,iEAAiE;gBACjE,MAAM,eAAe,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC;gBAElD,IAAI,CAAC,eAAe,EAAE;oBACpB,MAAM,IAAI,KAAK,CAAC,+BAA+B,YAAY,EAAE,CAAC,CAAC;iBAChE;gBAED,OAAO,eAAe,CAAC;aACxB;YAED,MAAM,CAAC,mBAAmB,CAAC,GAAG,MAAM,cAAc,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YAClE,MAAM,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;YAE/B,OAAO,mBAAmB,CAAC;QAC7B,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,uBAAuB,CAC3B,OAAmB,EACnB,YAAqB;QAErB,uBAAuB;QACvB,6EAA6E;QAC7E,4EAA4E;QAC5E,wDAAwD;QACxD,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,MAAM,WAAW,GAAG,MAAM,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,CAA2B,CAAC;YAE1D,IAAI,YAAY,IAAI,WAAW,CAAC,MAAM,KAAK,YAAY,EAAE;gBACvD,IAAI,YAAY,GAAG,WAAW,CAAC,MAAM,EAAE;oBACrC,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;iBAC5C;gBAED,MAAM,eAAe,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC;gBAClD,IAAA,+BAAuB,EAAC,eAAe,CAAC,CAAC;gBAEzC,OAAO,eAAe,CAAC;aACxB;YAED,MAAM,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;YAE7B,MAAM,mBAAmB,GAAG,CAAC,MAAM,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,CAA2B,CAAC,CAAC,IAAI,CACtE,CAAC,eAAe,EAAE,EAAE,CAAC,CAAC,WAAW,CAAC,QAAQ,CAAC,eAAe,CAAC,CAC5D,CAAC;YACF,IAAA,+BAAuB,EAAC,mBAAmB,CAAC,CAAC;YAE7C,OAAO,mBAAmB,CAAC;QAC7B,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;OAQG;IACH,KAAK,CAAC,wBAAwB,CAC5B,QAAgB,EAChB,IAAgB;QAEhB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;YAEhC,MAAM,uBAAA,IAAI,kFAA2B,MAA/B,IAAI,EAA4B,QAAQ,EAAE;gBAC9C,IAAI,EAAE,YAAY,CAAC,EAAE;gBACrB,IAAI,EAAE;oBACJ,QAAQ,EAAE,IAAI;oBACd,gBAAgB,EAAE,CAAC;iBACpB;aACF,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;OAQG;IACH,KAAK,CAAC,yBAAyB,CAAC,QAAgB;QAC9C,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,MAAM,QAAQ,GAAG,MAAM,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,CAA2B,CAAC;YACvD,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;gBACpB,MAAM,uBAAA,IAAI,kFAA2B,MAA/B,IAAI,EAA4B,QAAQ,EAAE;oBAC9C,IAAI,EAAE,YAAY,CAAC,EAAE;iBACtB,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,aAAa,CACjB,IAA2B,EAC3B,IAAc;QAEd,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,IAAI,IAAI,KAAK,YAAY,CAAC,EAAE,EAAE;YAC5B,OAAO,uBAAA,IAAI,2EAAoB,MAAxB,IAAI,EAAqB,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;SACjE;QAED,OAAO,uBAAA,IAAI,2EAAoB,MAAxB,IAAI,EACT,MAAM,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE,CAAC,uBAAA,IAAI,mEAAY,MAAhB,IAAI,EAAa,IAAI,EAAE,IAAI,CAAC,CAAC,CACxE,CAAC;IACJ,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,cAAc,CAAC,QAAgB;QACnC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,UAAU,CAAC,CAAC;SACpD;QACD,MAAM,uBAAA,IAAI,oCAAW,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;IAC5D,CAAC;IAED;;;;OAIG;IACH,UAAU;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,gBAAgB,CACpB,QAAgB,EAChB,SAAkB;QAElB,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;QACpC,MAAM,eAAe,GAAG,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,EAA0B,SAAS,CAAC,CAAC;QACjE,IAAI,CAAC,eAAe,EAAE;YACpB,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACtC;QACD,2BAA2B,CAAC,eAAe,CAAC,CAAC;QAE7C,OAAO,eAAe,CAAC,QAAQ,CAAC;IAClC,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,aAAa,CAAC,QAAgB,EAAE,OAAe;QACnD,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;QAEpC,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QACzE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE;YAC1B,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,wBAAwB,CAAC,CAAC;SAClE;QAED,OAAO,MAAM,OAAO,CAAC,aAAa,CAAC,SAAS,CAAC,OAAO,CAAQ,CAAC,CAAC;IAChE,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,WAAW;QACf,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,CAC/B,CAAC,QAAQ,EAAE,OAAO,EAAE,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,EACxD,EAAE,CACH,CAAC;IACJ,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,sBAAsB,CAC1B,OAAe,EACf,IAA8B;QAE9B,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,OAAO,CAAQ,CAAC;QAC7C,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QACzE,IAAI,CAAC,OAAO,CAAC,sBAAsB,EAAE;YACnC,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,iCAAiC,CAAC,CAAC;SAC3E;QAED,OAAO,MAAM,OAAO,CAAC,sBAAsB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;IAC7D,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,cAAc,CAAC,aAGpB;QACC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,aAAa,CAAC,IAAI,CAAQ,CAAC;QACxD,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QACzE,IAAI,CAAC,OAAO,CAAC,cAAc,EAAE;YAC3B,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,yBAAyB,CAAC,CAAC;SACnE;QAED,OAAO,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC;IAC7D,CAAC;IAED;;;;;;;;;OASG;IACH,KAAK,CAAC,oBAAoB,CAAC,OAAe;QACxC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC;QAEnC,MAAM,UAAU,GAAG,MAAM,OAAO,CAAC,GAAG,CAClC,uBAAA,IAAI,mCAAU,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,OAAO,EAAE,EAAE,EAAE;YACvC,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QACvD,CAAC,CAAC,CACH,CAAC;QAEF,MAAM,OAAO,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,SAAS,EAAE,EAAE;YAC9C,MAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YAC7C,OAAO,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;QAEH,IAAI,OAAO,CAAC,MAAM,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE;YACxC,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SACtB;QAED,gCAAgC;QAChC,IAAI,SAAS,GAAG,EAAE,CAAC;QACnB,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;YACtB,SAAS,GAAG,uBAAuB,CAAC;SACrC;aAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;YAC1B,SAAS,GAAG,gDAAgD,CAAC;SAC9D;QACD,MAAM,IAAI,KAAK,CACb,GAAG,kCAAsB,CAAC,SAAS,iBAAiB,SAAS,EAAE,CAChE,CAAC;IACJ,CAAC;IAED;;;;;;;;OAQG;IACH,iBAAiB,CAAC,IAA2B;QAC3C,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,OAAO,uBAAA,IAAI,mCAAU;aAClB,MAAM,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,CAAC,IAAI,KAAK,IAAI,CAAC;aAC9C,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;IACnC,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,kBAAkB;QACtB,OAAO,uBAAA,IAAI,qEAAc,MAAlB,IAAI,EAAe,KAAK,IAAI,EAAE;YACnC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;YAEzB,MAAM,uBAAA,IAAI,oEAAa,MAAjB,IAAI,CAAe,CAAC;YAC1B,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,yBAAyB,CAC7B,QAA+B;IAC/B,gCAAgC;IAChC,8DAA8D;IAC9D,IAAW;QAEX,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,IAAI,UAAU,CAAC;YACf,QAAQ,QAAQ,EAAE;gBAChB,KAAK,qBAAqB,CAAC,UAAU;oBACnC,MAAM,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC;oBAC3B,IAAI,CAAC,WAAW,EAAE;wBAChB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;qBAChD;oBACD,MAAM,QAAQ,GAAG,IAAA,aAAK,EAAC,WAAW,CAAC,CAAC;oBAEpC,IAAI,kBAAkB,CAAC;oBACvB,IAAI;wBACF,kBAAkB,GAAG,IAAA,kBAAU,EAAC,QAAQ,CAAC,CAAC;qBAC3C;oBAAC,MAAM;wBACN,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;qBACvD;oBAED,IACE,CAAC,IAAA,qBAAc,EAAC,kBAAkB,CAAC;wBACnC,wCAAwC;wBACxC,IAAA,oBAAa,EAAC,QAAQ,CAAC,KAAK,EAAE,GAAG,IAAI,CAAC,MAAM,EAC5C;wBACA,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;qBACvD;oBAED,UAAU,GAAG,IAAA,gBAAQ,EAAC,QAAQ,CAAC,CAAC;oBAChC,MAAM;gBACR,KAAK,qBAAqB,CAAC,IAAI;oBAC7B,IAAI,MAAM,CAAC;oBACX,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,GAAG,IAAI,CAAC;oBAC/B,IAAI;wBACF,MAAM,GAAG,8BAAS,CAAC,eAAe,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;qBACrD;oBAAC,OAAO,CAAC,EAAE;wBACV,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,2BAAM,CAAC,MAAM,CAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;qBACjE;oBACD,UAAU,GAAG,IAAA,kBAAU,EAAC,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC;oBAChD,MAAM;gBACR;oBACE,MAAM,IAAI,KAAK,CAAC,gCAAgC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;aACxE;YACD,MAAM,UAAU,GAAG,CAAC,MAAM,uBAAA,IAAI,mEAAY,MAAhB,IAAI,EAAa,YAAY,CAAC,MAAM,EAAE;gBAC9D,UAAU;aACX,CAAC,CAAe,CAAC;YAClB,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,WAAW,EAAE,CAAC;YAChD,OAAO,QAAQ,CAAC,CAAC,CAAC,CAAC;QACrB,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,aAAa,CAAC,OAAe;QACjC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,MAAM,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACvC,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;YAEzE,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,EAAE,EAAE,CACxD,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAC9B,CAAC;YAEF,MAAM,gBAAgB,GAAG,YAAY,KAAK,CAAC,CAAC;YAC5C,MAAM,mBAAmB,GAAG,CAAC,MAAM,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;YAEvE,yFAAyF;YACzF,IAAI,gBAAgB,IAAI,mBAAmB,EAAE;gBAC3C,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,2BAA2B,CAAC,CAAC;aACrE;YAED,yDAAyD;YACzD,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE;gBAC1B,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,wBAAwB,CAAC,CAAC;aAClE;YAED,0EAA0E;YAC1E,2DAA2D;YAC3D,uEAAuE;YACvE,6EAA6E;YAC7E,4DAA4D;YAC5D,OAAO,CAAC,aAAa,CAAC,OAAc,CAAC,CAAC;YAEtC,IAAI,mBAAmB,EAAE;gBACvB,MAAM,uBAAA,IAAI,4EAAqB,MAAzB,IAAI,CAAuB,CAAC;aACnC;QACH,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,GAAG,IAAI,iBAAiB,EAAE,OAAO,CAAC,CAAC;IAClE,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,SAAS;QACb,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,qEAAc,MAAlB,IAAI,EAAe,KAAK,IAAI,EAAE;YACnC,uBAAA,IAAI,wFAAiC,MAArC,IAAI,CAAmC,CAAC;YAExC,uBAAA,IAAI,+BAAa,SAAS,MAAA,CAAC;YAC3B,MAAM,uBAAA,IAAI,sEAAe,MAAnB,IAAI,CAAiB,CAAC;YAE5B,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;gBACpB,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC;gBACzB,KAAK,CAAC,QAAQ,GAAG,EAAE,CAAC;gBACpB,OAAO,KAAK,CAAC,aAAa,CAAC;gBAC3B,OAAO,KAAK,CAAC,cAAc,CAAC;YAC9B,CAAC,CAAC,CAAC;YAEH,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,CAAC;QAC/C,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,WAAW,CAAC,aAAoC;QACpD,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE;YACvB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;SAChD;QAED,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,aAAa,CAAC,IAAI,CAAQ,CAAC;QACxD,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QACzE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,sBAAsB,CAAC,CAAC;SAChE;QAED,OAAO,MAAM,OAAO,CAAC,WAAW,CAAC,OAAO,EAAE,aAAa,CAAC,IAAI,CAAC,CAAC;IAChE,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,wBAAwB,CAC5B,MAAkC;QAElC,MAAM,IAAI,GAAG,IAAA,wBAAY,EAAC,MAAM,CAAC,IAAI,CAAQ,CAAC;QAE9C,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAe,CAAC;QAEtE,IAAI,CAAC,OAAO,CAAC,wBAAwB,EAAE;YACrC,MAAM,IAAI,KAAK,CACb,kCAAsB,CAAC,mCAAmC,CAC3D,CAAC;SACH;QAED,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,MAAM,CAAC;QAClC,MAAM,eAAe,GAAG,IAAA,wBAAY,EAAC,MAAM,CAAC,eAAe,CAE9C,CAAC;QAEd,IAAI,eAAe,KAAK,SAAS,EAAE;YACjC,MAAM,IAAI,KAAK,CACb,kCAAsB,CAAC,0CAA0C,CAClE,CAAC;SACH;QAED,OAAO,MAAM,OAAO,CAAC,wBAAwB,CAAC,IAAI,EAAE;YAClD,OAAO;YACP,eAAe;YACf,KAAK;SACN,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,mBAAmB,CAAC,aAAoC;QAC5D,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,aAAa,CAAC,IAAI,CAAQ,CAAC;QACxD,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QACzE,IAAI,CAAC,OAAO,CAAC,mBAAmB,EAAE;YAChC,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,8BAA8B,CAAC,CAAC;SACxE;QAED,MAAM,cAAc,GAAG,SAAS,CAAC,aAAa,CAAC,IAAI,CAAQ,CAAC;QAE5D,OAAO,MAAM,OAAO,CAAC,mBAAmB,CAAC,OAAO,EAAE,cAAc,CAAC,CAAC;IACpE,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,gBAAgB,CACpB,aAAiC,EACjC,OAA6B;QAE7B,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,IAAI;YACF,IACE,CAAC;gBACC,oBAAoB,CAAC,EAAE;gBACvB,oBAAoB,CAAC,EAAE;gBACvB,oBAAoB,CAAC,EAAE;aACxB,CAAC,QAAQ,CAAC,OAAO,CAAC,EACnB;gBACA,MAAM,IAAI,KAAK,CAAC,yCAAyC,OAAO,GAAG,CAAC,CAAC;aACtE;YAED,+EAA+E;YAC/E,0DAA0D;YAC1D,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,aAAa,CAAC,IAAI,CAAQ,CAAC;YACxD,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;YACzE,IAAI,CAAC,OAAO,CAAC,aAAa,EAAE;gBAC1B,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,2BAA2B,CAAC,CAAC;aACrE;YAED,OAAO,MAAM,OAAO,CAAC,aAAa,CAChC,OAAO,EACP,OAAO,KAAK,oBAAoB,CAAC,EAAE;gBACjC,OAAO,aAAa,CAAC,IAAI,KAAK,QAAQ;gBACtC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC;gBAChC,CAAC,CAAC,aAAa,CAAC,IAAI,EACtB,EAAE,OAAO,EAAE,CACZ,CAAC;SACH;QAAC,OAAO,KAAK,EAAE;YACd,gFAAgF;YAChF,4EAA4E;YAC5E,MAAM,IAAI,KAAK,CAAC,wCAAwC,KAAK,EAAE,CAAC,CAAC;SAClE;IACH,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,eAAe,CACnB,WAA6B,EAC7B,IAAY,EACZ,IAA8B;QAE9B,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,IAAI,CAAQ,CAAC;QAC1C,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QACzE,IAAI,CAAC,OAAO,CAAC,eAAe,EAAE;YAC5B,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,0BAA0B,CAAC,CAAC;SACpE;QAED,OAAO,MAAM,OAAO,CAAC,eAAe,CAAC,OAAO,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;IACnE,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,oBAAoB,CACxB,IAAY,EACZ,YAAkC,EAClC,gBAAyC;QAEzC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,IAAI,CAAQ,CAAC;QAC1C,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QAEzE,IAAI,CAAC,OAAO,CAAC,oBAAoB,EAAE;YACjC,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,+BAA+B,CAAC,CAAC;SACzE;QAED,OAAO,MAAM,OAAO,CAAC,oBAAoB,CACvC,OAAO,EACP,YAAY,EACZ,gBAAgB,CACjB,CAAC;IACJ,CAAC;IAED;;;;;;;;OAQG;IACH,KAAK,CAAC,kBAAkB,CACtB,IAAY,EACZ,MAAwB,EACxB,gBAAyC;QAEzC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,IAAI,CAAQ,CAAC;QAC1C,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QAEzE,IAAI,CAAC,OAAO,CAAC,kBAAkB,EAAE;YAC/B,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,6BAA6B,CAAC,CAAC;SACvE;QAED,OAAO,MAAM,OAAO,CAAC,kBAAkB,CAAC,OAAO,EAAE,MAAM,EAAE,gBAAgB,CAAC,CAAC;IAC7E,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,iBAAiB,CACrB,IAAY,EACZ,MAAwB,EACxB,gBAAyC;QAEzC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,MAAM,OAAO,GAAG,IAAA,wBAAY,EAAC,IAAI,CAAQ,CAAC;QAC1C,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QAEzE,IAAI,CAAC,OAAO,CAAC,iBAAiB,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,4BAA4B,CAAC,CAAC;SACtE;QAED,OAAO,MAAM,OAAO,CAAC,iBAAiB,CAAC,OAAO,EAAE,MAAM,EAAE,gBAAgB,CAAC,CAAC;IAC5E,CAAC;IAED;;;;;OAKG;IACH,cAAc,CAAC,QAAgB;QAC7B,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,2CAA2C;QAC3C,IAAI,uBAAA,IAAI,mCAAU,KAAK,QAAQ,EAAE;YAC/B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC1B;QAED,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;YAEhC,uBAAA,IAAI,+BAAa,QAAQ,MAAA,CAAC;YAC1B,sDAAsD;YACtD,wDAAwD;YACxD,oBAAoB;YACpB,IAAI,uBAAA,IAAI,6CAAoB,EAAE;gBAC5B,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;oBACpB,OAAO,KAAK,CAAC,aAAa,CAAC;oBAC3B,OAAO,KAAK,CAAC,cAAc,CAAC;gBAC9B,CAAC,CAAC,CAAC;aACJ;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;;;OAQG;IACH,KAAK,CAAC,mBAAmB,CACvB,aAAqB,EACrB,cAAuB;QAEvB,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,uBAAA,IAAI,qEAAc,MAAlB,IAAI,EAAe,KAAK,IAAI,EAAE;YAC1D,MAAM,MAAM,GAAG,MAAM,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EACvB,SAAS,EACT,aAAa,EACb,cAAc,CACf,CAAC;YACF,uBAAA,IAAI,oEAAa,MAAjB,IAAI,CAAe,CAAC;YACpB,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC,CAAC;QAEH,IAAI;YACF,sDAAsD;YACtD,oCAAoC;YACpC,MAAM,uBAAA,IAAI,qEAAc,MAAlB,IAAI,EAAe,KAAK,IAAI,EAAE;gBAClC,IAAI,WAAW,EAAE;oBACf,MAAM,uBAAA,IAAI,oEAAa,MAAjB,IAAI,CAAe,CAAC;iBAC3B;YACH,CAAC,CAAC,CAAC;SACJ;QAAC,OAAO,KAAK,EAAE;YACd,uDAAuD;YACvD,4CAA4C;YAC5C,OAAO,CAAC,KAAK,CAAC,sCAAsC,EAAE,KAAK,CAAC,CAAC;SAC9D;IACH,CAAC;IAED;;;;OAIG;IACH,KAAK,CAAC,mBAAmB;QACvB,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,MAAM,uBAAA,IAAI,2EAAoB,MAAxB,IAAI,EAAqB,KAAK,IAAI,EAAE;YAC/C,MAAM,EAAE,aAAa,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;YACrC,wBAAwB,CAAC,aAAa,CAAC,CAAC;YAExC,OAAO,aAAa,CAAC;QACvB,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,cAAc,CAAC,QAAgB;QACnC,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,uBAAA,IAAI,qEAAc,MAAlB,IAAI,EAAe,KAAK,IAAI,EAAE;YAC1D,MAAM,MAAM,GAAG,MAAM,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EAAiB,QAAQ,CAAC,CAAC;YACpD,uBAAA,IAAI,oEAAa,MAAjB,IAAI,CAAe,CAAC;YACpB,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC,CAAC;QAEH,IAAI;YACF,wDAAwD;YACxD,sDAAsD;YACtD,oCAAoC;YACpC,MAAM,uBAAA,IAAI,qEAAc,MAAlB,IAAI,EAAe,KAAK,IAAI,EAAE;gBAClC,IAAI,WAAW,IAAI,uBAAA,IAAI,iFAA0B,MAA9B,IAAI,CAA4B,EAAE;oBACnD,MAAM,uBAAA,IAAI,oEAAa,MAAjB,IAAI,CAAe,CAAC;iBAC3B;YACH,CAAC,CAAC,CAAC;SACJ;QAAC,OAAO,KAAK,EAAE;YACd,uDAAuD;YACvD,4CAA4C;YAC5C,OAAO,CAAC,KAAK,CAAC,sCAAsC,EAAE,KAAK,CAAC,CAAC;SAC9D;IACH,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,gBAAgB,CAAC,SAAkB;QACvC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,2EAAoB,MAAxB,IAAI,EAAqB,KAAK,IAAI,EAAE,CACzC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,EAAmB,SAAS,CAAC,CAClC,CAAC;IACJ,CAAC;IAoED,KAAK,CAAC,WAAW,CAIf,QAAyB,EACzB,SAM6B,EAC7B,UAE0D;QACxD,eAAe,EAAE,KAAK;KACvB;QAED,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,IAAI,OAAoC,CAAC;YAEzC,IAAI,SAAS,IAAI,QAAQ,EAAE;gBACzB,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAE/C,CAAC;aACf;iBAAM,IAAI,MAAM,IAAI,QAAQ,EAAE;gBAC7B,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,QAAQ,CAAC,KAAK,IAAI,CAAC,CAEtD,CAAC;gBAEd,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,eAAe,EAAE;oBACvC,OAAO,GAAG,CAAC,MAAM,uBAAA,IAAI,mEAAY,MAAhB,IAAI,EACnB,QAAQ,CAAC,IAAI,EACb,OAAO,CAAC,cAAc,CACvB,CAAoB,CAAC;iBACvB;aACF;iBAAM,IAAI,IAAI,IAAI,QAAQ,EAAE;gBAC3B,OAAO,GAAG,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EAAiB,QAAQ,CAAC,EAAE,CAAoB,CAAC;aAChE;YAED,IAAI,CAAC,OAAO,EAAE;gBACZ,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,eAAe,CAAC,CAAC;aACzD;YAED,MAAM,MAAM,GAAG,MAAM,SAAS,CAAC;gBAC7B,OAAO;gBACP,QAAQ,EAAE,uBAAA,IAAI,2EAAoB,MAAxB,IAAI,EAAqB,OAAO,CAAC;aAC5C,CAAC,CAAC;YAEH,IAAI,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE;gBAC9B,gEAAgE;gBAChE,gEAAgE;gBAChE,gEAAgE;gBAChE,qDAAqD;gBACrD,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,yBAAyB,CAAC,CAAC;aACnE;YAED,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,8BAA8B;IAE9B;;;;;OAKG;IACH,YAAY;QACV,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QACzB,yEAAyE;QACzE,OAAO,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,CAAyB,CAAC;IAC5E,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,iBAAiB;QACrB,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,CACL,IAAI,CAAC,YAAY,EAAE;YACnB,CAAC,MAAM,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE,CAAC,uBAAA,IAAI,qEAAc,MAAlB,IAAI,CAAgB,CAAC,CAAC,CAClE,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACH,gCAAgC;IAChC,8DAA8D;IAC9D,KAAK,CAAC,gBAAgB,CAAC,UAAe;QACpC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,uBAAA,IAAI,qEAAc,MAAlB,IAAI,CAAgB,CAAC,CAAC;YACpE,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,mBAAmB;QACvB,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC;IAChD,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,iBAAiB;QACrB,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;IACxD,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,mBAAmB,CAAC,WAAmB;QAC3C,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;IAClE,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,qBAAqB,CAAC,aAAqB;QAC/C,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;IACtE,CAAC;IAED;;;;;;;OAOG;IACH,KAAK,CAAC,iBAAiB,CACrB,SAAiB,EACjB,YAAoB;QAEpB,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,eAAe,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC;IAC5E,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,mBAAmB;QACvB,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,iBAAiB,EAAE,CAAC;IACvD,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,uBAAuB;QAC3B,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC;IAChD,CAAC;IAED;;;;;;;;OAQG;IACH,KAAK,CAAC,iBAAiB,CACrB,IAAY;QAEZ,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,IAAI;gBACF,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,uBAAA,IAAI,qEAAc,MAAlB,IAAI,CAAgB,CAAC,CAAC;gBACpE,IAAI,QAAQ,CAAC;gBACb,QAAQ,IAAI,EAAE;oBACZ,KAAK,CAAC,CAAC;wBACL,QAAQ,GAAG,MAAM,OAAO,CAAC,eAAe,EAAE,CAAC;wBAC3C,MAAM;oBACR,KAAK,CAAC;wBACJ,QAAQ,GAAG,MAAM,OAAO,CAAC,WAAW,EAAE,CAAC;wBACvC,MAAM;oBACR;wBACE,QAAQ,GAAG,MAAM,OAAO,CAAC,YAAY,EAAE,CAAC;iBAC3C;gBACD,gCAAgC;gBAChC,8DAA8D;gBAC9D,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAY,EAAE,EAAE;oBACnC,OAAO;wBACL,GAAG,OAAO;wBACV,OAAO,EAAE,KAAK;qBACf,CAAC;gBACJ,CAAC,CAAC,CAAC;aACJ;YAAC,OAAO,CAAC,EAAE;gBACV,8CAA8C;gBAC9C,0BAA0B;gBAC1B,gFAAgF;gBAChF,4EAA4E;gBAC5E,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,EAAE,CAAC,CAAC;aACrE;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,6BAA6B,CAAC,KAAa;QAC/C,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,uBAAA,IAAI,qEAAc,MAAlB,IAAI,CAAgB,CAAC,CAAC;YAEpE,OAAO,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;YAClC,MAAM,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,qBAAqB,CAAC,OAAe;QACzC,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAe,CAAC;QACzE,OAAO,OAAO,CAAC,IAAI,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,cAAc;QAIlB,uBAAA,IAAI,yEAAkB,MAAtB,IAAI,CAAoB,CAAC;QAEzB,OAAO,uBAAA,IAAI,0EAAmB,MAAvB,IAAI,EAAoB,KAAK,IAAI,EAAE;YACxC,MAAM,OAAO,GAAG,IAAI,CAAC,YAAY,EAAE,CAAC;YAEpC,IAAI,CAAC,OAAO,EAAE;gBACZ,OAAO,EAAE,eAAe,EAAE,EAAE,EAAE,iBAAiB,EAAE,EAAE,EAAE,CAAC;aACvD;YAED,MAAM,WAAW,GAAG,CAAC,MAAM,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,CAA2B,CAAa,CAAC;YACxE,OAAO,CAAC,YAAY,EAAE,CAAC;YACvB,MAAM,iBAAiB,GACrB,CAAC,MAAM,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,CAA2B,CAAa,CAAC;YACtD,MAAM,eAAe,GAAG,WAAW,CAAC,MAAM,CACxC,CAAC,OAAe,EAAE,EAAE,CAAC,CAAC,iBAAiB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAC1D,CAAC;YACF,OAAO,EAAE,eAAe,EAAE,iBAAiB,EAAE,CAAC;QAChD,CAAC,CAAC,CAAC;IACL,CAAC;CA64BF;AAxoED,8CAwoEC;;IAt4BG,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,cAAc,EACrB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAC5B,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,2BAA2B,EAClC,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,IAAI,CAAC,CACzC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,sBAAsB,EAC7B,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CACpC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,mBAAmB,EAC1B,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,CACjC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,iBAAiB,EACxB,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAC/B,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,yBAAyB,EAChC,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CACvC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,cAAc,EACrB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAC5B,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,oBAAoB,EAC3B,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,uBAAuB,EAC9B,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CACrC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,qBAAqB,EAC5B,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CACnC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,uBAAuB,EAC9B,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CACrC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,qBAAqB,EAC5B,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CACnC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,oBAAoB,EAC3B,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,gBAAgB,EACvB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAC9B,CAAC;IAEF,IAAI,CAAC,eAAe,CAAC,qBAAqB,CACxC,GAAG,IAAI,cAAc,EACrB,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAC5B,CAAC;AACJ,CAAC,iFAQe,SAAiB;IAC/B,OAAO,uBAAA,IAAI,mCAAU,CAAC,IAAI,CAAC,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,CAAC,QAAQ,CAAC,EAAE,KAAK,SAAS,CAAC;QACrE,EAAE,OAAO,CAAC;AACd,CAAC,mGAQwB,SAAkB;IACzC,IAAI,CAAC,SAAS,EAAE;QACd,OAAO,uBAAA,IAAI,mCAAU,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC;KACnC;IAED,OAAO,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EAAiB,SAAS,CAAC,CAAC;AACzC,CAAC,yFAQmB,OAAgB;IAClC,MAAM,mBAAmB,GAAG,uBAAA,IAAI,mCAAU,CAAC,IAAI,CAC7C,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,OAAO,KAAK,OAAO,CAC7C,CAAC;IACF,IAAI,CAAC,mBAAmB,EAAE;QACxB,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,eAAe,CAAC,CAAC;KACzD;IACD,OAAO,mBAAmB,CAAC,QAAQ,CAAC;AACtC,CAAC,qGASC,IAAY;IAEZ,OAAO,uBAAA,IAAI,0CAAiB,CAAC,IAAI,CAC/B,CAAC,cAAc,EAAE,EAAE,CAAC,cAAc,CAAC,IAAI,KAAK,IAAI,CACjD,CAAC;AACJ,CAAC;AAED;;;;;;GAMG;AACH,KAAK;IACH,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IAEtC,yEAAyE;IACzE,OAAO,CAAC,MAAM,uBAAA,IAAI,mEAAY,MAAhB,IAAI,EAAa,YAAY,CAAC,EAAE,CAAC,CAAyB,CAAC;AAC3E,CAAC,yGAQ2B,SAAoB;IAC9C,uBAAA,IAAI,6CAA2B,CAAC,KAAK,EAAE,EAAE;QACvC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,GAAG,IAAI,uBAAuB,EAAE,KAAK,CAAC,CAAC;IACtE,CAAC,MAAA,CAAC;IAEF,SAAS,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,uBAAA,IAAI,iDAAwB,CAAC,CAAC;AAClE,CAAC;IAGC,MAAM,UAAU,GAAG,IAAI,CAAC,iBAAiB,CACvC,YAAY,CAAC,EAAE,CACU,CAAC;IAE5B,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,EAAE;QAC/B,IAAI,uBAAA,IAAI,iDAAwB,EAAE;YAChC,SAAS,CAAC,WAAW,EAAE,CAAC,WAAW,CAAC,uBAAA,IAAI,iDAAwB,CAAC,CAAC;SACnE;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;;;;;;;GAaG;AACH,KAAK,uDACH,QAAgB,EAChB,OAGC;IAED,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IAEtC,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;QAChC,MAAM,IAAI,SAAS,CAAC,kCAAsB,CAAC,iBAAiB,CAAC,CAAC;KAC/D;IAED,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;QACpB,OAAO,KAAK,CAAC,aAAa,CAAC;QAC3B,OAAO,KAAK,CAAC,cAAc,CAAC;IAC9B,CAAC,CAAC,CAAC;IAEH,uBAAA,IAAI,+BAAa,QAAQ,MAAA,CAAC;IAE1B,MAAM,uBAAA,IAAI,sEAAe,MAAnB,IAAI,CAAiB,CAAC;IAC5B,MAAM,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,EAAgC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;IACtE,uBAAA,IAAI,oEAAa,MAAjB,IAAI,CAAe,CAAC;AACtB,CAAC;AAED;;;;;GAKG;AACH,KAAK,8CAAmB,SAAkB;IACxC,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IAEtC,MAAM,OAAO,GAAG,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,EAA0B,SAAS,CAAC,CAAC;IAEzD,IAAI,CAAC,OAAO,EAAE;QACZ,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,eAAe,CAAC,CAAC;KACzD;IAED,wEAAwE;IACxE,IAAI,OAAO,CAAC,IAAI,KAAK,YAAY,CAAC,EAAE,EAAE;QACpC,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,2BAA2B,CAAC,CAAC;KACrE;IAED,2BAA2B,CAAC,OAAO,CAAC,CAAC;IAErC,MAAM,SAAS,GAAG,OAAO,CAAC,QAAQ,CAAC;IACnC,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,WAAW,EAAE,CAAC;IAC7C,wBAAwB;IACxB,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;QACzB,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;KACpD;IAED,sDAAsD;IACtD,oEAAoE;IACpE,MAAM,gBAAgB,GAAG,uBAAA,IAAI,iFAA0B,MAA9B,IAAI,EAA2B,YAAY,CAAC,EAAE,CAAE,CAAC;IAE1E,MAAM,SAAS,GAAG,gBAAgB,EAAE,CAAC;IACrC,8DAA8D;IAC9D,uDAAuD;IACvD,MAAM,SAAS,CAAC,WAAW,CAAC;QAC1B,QAAQ,EAAE,SAAS;QACnB,gBAAgB,EAAE,QAAQ,CAAC,MAAM;KAClC,CAAC,CAAC;IACH,MAAM,YAAY,GAAG,MAAM,SAAS,CAAC,WAAW,EAAE,CAAC;IACnD,wBAAwB;IACxB,IAAI,YAAY,CAAC,MAAM,KAAK,QAAQ,CAAC,MAAM,EAAE;QAC3C,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;KACvE;IAED,YAAY,CAAC,OAAO,CAAC,CAAC,OAAe,EAAE,CAAS,EAAE,EAAE;QAClD,wBAAwB;QACxB,IAAI,OAAO,CAAC,WAAW,EAAE,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE;YACvD,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;SAC7D;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,SAAS,CAAC;AACnB,CAAC;AAED;;;;;GAKG;AACH,KAAK;IACH,OAAO,OAAO,CAAC,GAAG,CAAC,uBAAA,IAAI,mCAAU,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC,CAAC;AAC5D,CAAC;AAED;;;;;;;GAOG;AACH,KAAK,mDACH,EAAE,kBAAkB,KAAsC;IACxD,kBAAkB,EAAE,IAAI;CACzB;IAED,MAAM,kBAAkB,GAAwB,MAAM,OAAO,CAAC,GAAG,CAC/D,uBAAA,IAAI,mCAAU,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE;QACjD,OAAO;YACL,IAAI,EAAE,OAAO,CAAC,IAAI;YAClB,IAAI,EAAE,MAAM,OAAO,CAAC,SAAS,EAAE;YAC/B,QAAQ;SACT,CAAC;IACJ,CAAC,CAAC,CACH,CAAC;IAEF,IAAI,kBAAkB,EAAE;QACtB,kBAAkB,CAAC,IAAI,CAAC,GAAG,uBAAA,IAAI,8CAAqB,CAAC,CAAC;KACvD;IAED,OAAO,kBAAkB,CAAC;AAC5B,CAAC;AAED;;;;;GAKG;AACH,KAAK;IACH,OAAO;QACL,QAAQ,EAAE,MAAM,uBAAA,IAAI,8EAAuB,MAA3B,IAAI,CAAyB;QAC7C,QAAQ,EAAE,uBAAA,IAAI,mCAAU;KACzB,CAAC;AACJ,CAAC;AAED;;;;;GAKG;AACH,KAAK,uDACH,kBAAuC;IAKvC,MAAM,uBAAA,IAAI,sEAAe,MAAnB,IAAI,CAAiB,CAAC;IAC5B,MAAM,QAAQ,GAAyD,EAAE,CAAC;IAC1E,IAAI,WAAW,GAAG,KAAK,CAAC;IAExB,KAAK,MAAM,iBAAiB,IAAI,kBAAkB,EAAE;QAClD,MAAM,MAAM,GAAG,MAAM,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EAAiB,iBAAiB,CAAC,CAAC;QAC7D,IAAI,MAAM,EAAE;YACV,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,MAAM,CAAC;YACrC,QAAQ,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAC;YACrC,IAAI,MAAM,CAAC,WAAW,EAAE;gBACtB,WAAW,GAAG,IAAI,CAAC;aACpB;SACF;KACF;IAED,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,CAAC;AACnC,CAAC;AAED;;;;;;;;GAQG;AACH,KAAK,4CACH,QAA4B,EAC5B,aAAsB,EACtB,cAAuB;IAKvB,OAAO,uBAAA,IAAI,sEAAe,MAAnB,IAAI,EAAgB,KAAK,IAAI,EAAE;QACpC,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;QACxC,IAAI,CAAC,cAAc,EAAE;YACnB,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,UAAU,CAAC,CAAC;SACpD;QAED,IAAI,KAAK,CAAC;QACV,MAAM,YAAY,GAAoC,EAAE,CAAC;QAEzD,IAAI,uBAAA,IAAI,6CAAoB,EAAE;YAC5B,8BAA8B,CAAC,uBAAA,IAAI,oCAAW,CAAC,CAAC;YAEhD,IAAI,QAAQ,EAAE;gBACZ,MAAM,MAAM,GAAG,MAAM,uBAAA,IAAI,oCAAW,CAAC,iBAAiB,CACpD,QAAQ,EACR,cAAc,CACf,CAAC;gBACF,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;gBACrB,uBAAA,IAAI,+BAAa,QAAQ,MAAA,CAAC;gBAE1B,YAAY,CAAC,aAAa,GAAG,MAAM,CAAC,iBAAiB,CAAC;gBACtD,YAAY,CAAC,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC;aAC3C;iBAAM;gBACL,MAAM,oBAAoB,GAAG,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;gBAExD,IAAI,cAAc,IAAI,cAAc,KAAK,oBAAoB,CAAC,IAAI,EAAE;oBAClE,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,kBAAkB,CAAC,CAAC;iBAC5D;qBAAM;oBACL,cAAc,GAAG,oBAAoB,CAAC,IAAc,CAAC;iBACtD;gBAED,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;oBACrC,MAAM,IAAI,SAAS,CAAC,kCAAsB,CAAC,iBAAiB,CAAC,CAAC;iBAC/D;gBAED,MAAM,GAAG,GAAG,MAAM,uBAAA,IAAI,oCAAW,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC;gBAC3D,KAAK,GAAG,MAAM,uBAAA,IAAI,oCAAW,CAAC,cAAc,CAC1C,GAAG,EACH,oBAAoB,CACrB,CAAC;gBAEF,gEAAgE;gBAChE,iCAAiC;gBACjC,YAAY,CAAC,aAAa,GAAG,aAAa,CAAC;gBAC3C,YAAY,CAAC,cAAc,GAAG,cAAc,CAAC;aAC9C;SACF;aAAM;YACL,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;gBAChC,MAAM,IAAI,SAAS,CAAC,kCAAsB,CAAC,iBAAiB,CAAC,CAAC;aAC/D;YAED,KAAK,GAAG,MAAM,uBAAA,IAAI,oCAAW,CAAC,OAAO,CAAC,QAAQ,EAAE,cAAc,CAAC,CAAC;YAChE,uBAAA,IAAI,+BAAa,QAAQ,MAAA,CAAC;SAC3B;QAED,IAAI,CAAC,yBAAyB,CAAC,KAAK,CAAC,EAAE;YACrC,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,cAAc,CAAC,CAAC;SACxD;QAED,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,GAC7B,MAAM,uBAAA,IAAI,kFAA2B,MAA/B,IAAI,EAA4B,KAAK,CAAC,CAAC;QAE/C,MAAM,eAAe,GAAG,MAAM,uBAAA,IAAI,2EAAoB,MAAxB,IAAI,CAAsB,CAAC;QAEzD,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;YACpB,KAAK,CAAC,QAAQ,GAAG,eAAe,CAAC;YACjC,IAAI,YAAY,CAAC,aAAa,IAAI,YAAY,CAAC,cAAc,EAAE;gBAC7D,KAAK,CAAC,aAAa,GAAG,YAAY,CAAC,aAAa,CAAC;gBACjD,KAAK,CAAC,cAAc,GAAG,YAAY,CAAC,cAAc,CAAC;aACpD;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,CAAC;IACnC,CAAC,CAAC,CAAC;AACL,CAAC;IAQC,OAAO,uBAAA,IAAI,sEAAe,MAAnB,IAAI,EAAgB,KAAK,IAAI,EAAE;QACpC,8CAA8C;QAC9C,MAAM,uBAAA,IAAI,kFAA2B,MAA/B,IAAI,CAA6B,CAAC;QAExC,MAAM,EAAE,aAAa,EAAE,cAAc,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QAC5D,uBAAuB;QACvB,2FAA2F;QAC3F,wEAAwE;QACxE,EAAE;QACF,8FAA8F;QAC9F,yBAAyB;QACzB,MAAM,YAAY,GAChB,aAAa,IAAI,KAAK,IAAI,uBAAA,IAAI,oCAAW,CAAC,cAAc,EAAE,CAAC,KAAK,CAAC,CAAC;QAEpE,IAAI,CAAC,uBAAA,IAAI,mCAAU,IAAI,CAAC,aAAa,EAAE;YACrC,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,kBAAkB,CAAC,CAAC;SAC5D;QAED,MAAM,kBAAkB,GAAG,MAAM,uBAAA,IAAI,8EAAuB,MAA3B,IAAI,CAAyB,CAAC;QAE/D,IACE,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,OAAO,CAAC,IAAI,KAAK,YAAY,CAAC,EAAE,CAAC,EACvE;YACA,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,WAAW,CAAC,CAAC;SACrD;QAED,MAAM,YAAY,GAAoC,EAAE,CAAC;QAEzD,IAAI,uBAAA,IAAI,6CAAoB,EAAE;YAC5B,8BAA8B,CAAC,uBAAA,IAAI,oCAAW,CAAC,CAAC;YAEhD,IAAI,YAAY,EAAE;gBAChB,MAAM,GAAG,GAAG,MAAM,uBAAA,IAAI,oCAAW,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC;gBAC3D,MAAM,SAAS,GAAG,MAAM,uBAAA,IAAI,oCAAW,CAAC,cAAc,CACpD,GAAG,EACH,kBAAkB,CACnB,CAAC;gBACF,SAAS,CAAC,IAAI,GAAG,cAAc,CAAC;gBAChC,YAAY,CAAC,KAAK,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;aAChD;iBAAM,IAAI,uBAAA,IAAI,mCAAU,EAAE;gBACzB,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,iBAAiB,EAAE,GAC1C,MAAM,uBAAA,IAAI,oCAAW,CAAC,iBAAiB,CACrC,uBAAA,IAAI,mCAAU,EACd,kBAAkB,CACnB,CAAC;gBAEJ,YAAY,CAAC,KAAK,GAAG,QAAQ,CAAC;gBAC9B,YAAY,CAAC,aAAa,GAAG,iBAAiB,CAAC;aAChD;SACF;aAAM;YACL,qBAAqB,CAAC,uBAAA,IAAI,mCAAU,CAAC,CAAC;YACtC,YAAY,CAAC,KAAK,GAAG,MAAM,uBAAA,IAAI,oCAAW,CAAC,OAAO,CAChD,uBAAA,IAAI,mCAAU,EACd,kBAAkB,CACnB,CAAC;SACH;QAED,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE;YACvB,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,gBAAgB,CAAC,CAAC;SAC1D;QAED,MAAM,eAAe,GAAG,MAAM,uBAAA,IAAI,2EAAoB,MAAxB,IAAI,CAAsB,CAAC;QAEzD,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;YACpB,KAAK,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC;YACjC,KAAK,CAAC,QAAQ,GAAG,eAAe,CAAC;YACjC,IAAI,YAAY,CAAC,aAAa,EAAE;gBAC9B,KAAK,CAAC,aAAa,GAAG,YAAY,CAAC,aAAa,CAAC;gBACjD,KAAK,CAAC,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,KAAe,CAAC,CAAC,IAAI,CAAC;aACtE;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC;IACd,CAAC,CAAC,CAAC;AACL,CAAC;IAQC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;IAE7B,IAAI,CAAC,KAAK,IAAI,CAAC,uBAAA,IAAI,mCAAU,IAAI,CAAC,uBAAA,IAAI,oCAAW,CAAC,cAAc,EAAE;QAChE,OAAO,KAAK,CAAC;KACd;IAED,OAAO,CAAC,uBAAA,IAAI,oCAAW,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;AAChD,CAAC;AAED;;;;;;GAMG;AACH,KAAK,qDACH,qBAAmC,EAAE;IAErC,MAAM,QAAQ,GAAG,uBAAA,IAAI,mCAAU,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;IAE9D,MAAM,aAAa,GAAG,MAAM,OAAO,CAAC,GAAG,CACrC,CAAC,GAAG,QAAQ,EAAE,GAAG,kBAAkB,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE,CACzD,OAAO,CAAC,WAAW,EAAE,CACtB,CACF,CAAC;IACF,MAAM,SAAS,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,EAAE;QAClD,OAAO,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACzB,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,0EAA0E;IAC1E,wEAAwE;IACxE,OAAO,SAAS,CAAC,GAAG,CAAC,SAAS,CAAa,CAAC;AAC9C,CAAC;AAED;;;;;;;GAOG;AACH,KAAK,2DAAgC,IAAY,EAAE,IAAc;IAC/D,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IAEtC,MAAM,OAAO,GAAG,CAAC,MAAM,uBAAA,IAAI,mEAAY,MAAhB,IAAI,EAAa,IAAI,EAAE,IAAI,CAAC,CAAe,CAAC;IAEnE,MAAM,CAAC,YAAY,CAAC,GAAG,MAAM,OAAO,CAAC,WAAW,EAAE,CAAC;IACnD,IAAI,CAAC,YAAY,EAAE;QACjB,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,cAAc,CAAC,CAAC;KACxD;IACD,OAAO,YAAY,CAAC;AACtB,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,KAAK,wCAAa,IAAY,EAAE,IAAc;IAC5C,MAAM,OAAO,GAAG,MAAM,uBAAA,IAAI,sEAAe,MAAnB,IAAI,EAAgB,IAAI,EAAE,IAAI,CAAC,CAAC;IAEtD,uBAAA,IAAI,mCAAU,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAE,yBAAyB,EAAE,EAAE,CAAC,CAAC;IAExE,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,KAAK,2CAAgB,IAAY,EAAE,IAAc;IAC/C,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IAEtC,MAAM,cAAc,GAAG,uBAAA,IAAI,iFAA0B,MAA9B,IAAI,EAA2B,IAAI,CAAC,CAAC;IAE5D,IAAI,CAAC,cAAc,EAAE;QACnB,MAAM,IAAI,KAAK,CACb,GAAG,kCAAsB,CAAC,gBAAgB,mBAAmB,IAAI,EAAE,CACpE,CAAC;KACH;IAED,MAAM,OAAO,GAAG,cAAc,EAAE,CAAC;IACjC,IAAI,IAAI,EAAE;QACR,4DAA4D;QAC5D,MAAM,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;KACjC;IAED,IAAI,OAAO,CAAC,IAAI,EAAE;QAChB,MAAM,OAAO,CAAC,IAAI,EAAE,CAAC;KACtB;IAED,IAAI,IAAI,KAAK,YAAY,CAAC,EAAE,IAAI,CAAC,CAAC,IAAA,gBAAQ,EAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;QACnE,IAAI,CAAC,OAAO,CAAC,sBAAsB,EAAE;YACnC,MAAM,IAAI,KAAK,CACb,kCAAsB,CAAC,iCAAiC,CACzD,CAAC;SACH;QAED,wFAAwF;QACxF,iGAAiG;QACjG,2CAA2C;QAC3C,MAAM,OAAO,CAAC,sBAAsB,EAAE,CAAC;QACvC,MAAM,OAAO,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;KAC9B;IAED,IAAI,IAAI,KAAK,YAAY,CAAC,EAAE,EAAE;QAC5B,qDAAqD;QACrD,kCAAkC;QAClC,uBAAA,IAAI,mFAA4B,MAAhC,IAAI,EAA6B,OAA+B,CAAC,CAAC;KACnE;IAED,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;GAGG;AACH,KAAK;IACH,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IACtC,KAAK,MAAM,EAAE,OAAO,EAAE,IAAI,uBAAA,IAAI,mCAAU,EAAE;QACxC,MAAM,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EAAiB,OAAO,CAAC,CAAC;KACrC;IACD,uBAAA,IAAI,+BAAa,EAAE,MAAA,CAAC;IACpB,uBAAA,IAAI,0CAAwB,EAAE,MAAA,CAAC;AACjC,CAAC;AAED;;;;;;GAMG;AACH,KAAK,4CACH,UAA6B;IAK7B,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IAEtC,IAAI;QACF,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,kBAAkB,EAAE,GAAG,UAAU,CAAC;QAChE,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,IAAI,QAAQ,GAAG,kBAAkB,CAAC;QAClC,MAAM,OAAO,GAAG,MAAM,uBAAA,IAAI,sEAAe,MAAnB,IAAI,EAAgB,IAAI,EAAE,IAAI,CAAC,CAAC;QACtD,MAAM,uBAAA,IAAI,kFAA2B,MAA/B,IAAI,EAA4B,CAAC,OAAO,CAAC,CAAC,CAAC;QACjD,yEAAyE;QACzE,2BAA2B;QAC3B,IAAI,CAAC,QAAQ,EAAE;YACb,WAAW,GAAG,IAAI,CAAC;YACnB,QAAQ,GAAG,yBAAyB,EAAE,CAAC;SACxC;QACD,gFAAgF;QAChF,2DAA2D;QAC3D,uBAAA,IAAI,mCAAU,CAAC,IAAI,CAAC;YAClB,OAAO;YACP,QAAQ;SACT,CAAC,CAAC;QACH,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,CAAC;KAC3C;IAAC,OAAO,KAAK,EAAE;QACd,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACrB,uBAAA,IAAI,8CAAqB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC3C,OAAO,SAAS,CAAC;KAClB;AACH,CAAC;AAED;;;;;;;;GAQG;AACH,KAAK,4CAAiB,OAAmB;IACvC,MAAM,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;AAC5B,CAAC;AAED;;;;;GAKG;AACH,KAAK;IACH,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IACtC,MAAM,aAAa,GACjB,EAAE,CAAC;IAEL,sCAAsC;IACtC,iDAAiD;IACjD,oEAAoE;IAEpE,MAAM,OAAO,CAAC,GAAG,CACf,uBAAA,IAAI,mCAAU,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE;QACjD,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,WAAW,EAAE,CAAC;QAC7C,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YACvB,aAAa,CAAC,IAAI,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,CAAC;SAC3C;aAAM;YACL,MAAM,uBAAA,IAAI,uEAAgB,MAApB,IAAI,EAAiB,OAAO,CAAC,CAAC;SACrC;IACH,CAAC,CAAC,CACH,CAAC;IACF,uBAAA,IAAI,+BAAa,aAAa,MAAA,CAAC;AACjC,CAAC;AAED;;;;;GAKG;AACH,KAAK,uDACH,qBAAmC,EAAE;IAErC,MAAM,QAAQ,GAAG,MAAM,uBAAA,IAAI,gFAAyB,MAA7B,IAAI,EAA0B,kBAAkB,CAAC,CAAC;IAEzE,IAAI,IAAI,GAAG,CAAC,QAAQ,CAAC,CAAC,IAAI,KAAK,QAAQ,CAAC,MAAM,EAAE;QAC9C,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,iBAAiB,CAAC,CAAC;KAC3D;AACH,CAAC;IASC,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IAEtC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;QACpB,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC;IAC1B,CAAC,CAAC,CAAC;IACH,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,GAAG,IAAI,SAAS,CAAC,CAAC;AACjD,CAAC;IAQC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,gBAAgB,CAAC,CAAC;KAC1D;AACH,CAAC;AAED;;;;;;;GAOG;AACH,KAAK,+CACH,QAA2C;IAE3C,OAAO,uBAAA,IAAI,qEAAc,MAAlB,IAAI,EAAe,KAAK,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE;QAClD,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,uBAAA,IAAI,wEAAiB,MAArB,IAAI,CAAmB,CAAC,CAAC;QAC/D,MAAM,cAAc,GAAG,MAAM,QAAQ,CAAC,EAAE,WAAW,EAAE,CAAC,CAAC;QACvD,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,uBAAA,IAAI,wEAAiB,MAArB,IAAI,CAAmB,CAAC,CAAC;QAE/D,6FAA6F;QAC7F,IAAI,CAAC,IAAA,gBAAO,EAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE;YAChC,MAAM,uBAAA,IAAI,oEAAa,MAAjB,IAAI,CAAe,CAAC;SAC3B;QAED,OAAO,cAAc,CAAC;IACxB,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;;GAMG;AACH,KAAK,0CACH,QAA2C;IAE3C,OAAO,uBAAA,IAAI,2EAAoB,MAAxB,IAAI,EAAqB,KAAK,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE;QACxD,MAAM,yBAAyB,GAAG,MAAM,uBAAA,IAAI,8EAAuB,MAA3B,IAAI,CAAyB,CAAC;QACtE,MAAM,eAAe,GAAG,uBAAA,IAAI,mCAAU,CAAC;QAEvC,IAAI;YACF,OAAO,MAAM,QAAQ,CAAC,EAAE,WAAW,EAAE,CAAC,CAAC;SACxC;QAAC,OAAO,CAAC,EAAE;YACV,6DAA6D;YAC7D,uBAAA,IAAI,+BAAa,eAAe,MAAA,CAAC;YACjC,MAAM,uBAAA,IAAI,kFAA2B,MAA/B,IAAI,EAA4B,yBAAyB,CAAC,CAAC;YAEjE,MAAM,CAAC,CAAC;SACT;IACH,CAAC,CAAC,CAAC;AACL,CAAC;IAQC,IAAI,CAAC,uBAAA,IAAI,mDAA0B,CAAC,QAAQ,EAAE,EAAE;QAC9C,MAAM,IAAI,KAAK,CAAC,kCAAsB,CAAC,sBAAsB,CAAC,CAAC;KAChE;AACH,CAAC;AAED;;;;;;;;;;;GAWG;AACH,KAAK,gDACH,QAA2C;IAE3C,OAAO,QAAQ,CAAC,uBAAA,IAAI,mDAA0B,EAAE,QAAQ,CAAC,CAAC;AAC5D,CAAC;AAED;;;;;;;;;;GAUG;AACH,KAAK,2CACH,QAA2C;IAE3C,uBAAA,IAAI,sFAA+B,MAAnC,IAAI,CAAiC,CAAC;IAEtC,OAAO,QAAQ,CAAC,uBAAA,IAAI,8CAAqB,EAAE,QAAQ,CAAC,CAAC;AACvD,CAAC;AAGH;;;;;;;;GAQG;AACH,KAAK,UAAU,QAAQ,CACrB,KAAY,EACZ,QAA2C;IAE3C,MAAM,WAAW,GAAG,MAAM,KAAK,CAAC,OAAO,EAAE,CAAC;IAE1C,IAAI;QACF,OAAO,MAAM,QAAQ,CAAC,EAAE,WAAW,EAAE,CAAC,CAAC;KACxC;YAAS;QACR,WAAW,EAAE,CAAC;KACf;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,yBAAyB;IAChC,OAAO,EAAE,EAAE,EAAE,IAAA,WAAI,GAAE,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC;AAClC,CAAC;AAED,kBAAe,iBAAiB,CAAC","sourcesContent":["import type { TypedTransaction, TypedTxData } from '@ethereumjs/tx';\nimport { isValidPrivate, getBinarySize } from '@ethereumjs/util';\nimport type {\n  MetaMaskKeyring as QRKeyring,\n  IKeyringState as IQRKeyringState,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport type { RestrictedMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport * as encryptorUtils from '@metamask/browser-passworder';\nimport { HdKeyring } from '@metamask/eth-hd-keyring';\nimport { normalize as ethNormalize } from '@metamask/eth-sig-util';\nimport SimpleKeyring from '@metamask/eth-simple-keyring';\nimport type {\n  KeyringExecutionContext,\n  EthBaseTransaction,\n  EthBaseUserOperation,\n  EthUserOperation,\n  EthUserOperationPatch,\n} from '@metamask/keyring-api';\nimport type { EthKeyring } from '@metamask/keyring-internal-api';\nimport type { KeyringClass } from '@metamask/keyring-utils';\nimport type { Eip1024EncryptedData, Hex, Json } from '@metamask/utils';\nimport {\n  add0x,\n  assertIsStrictHexString,\n  bytesToHex,\n  hasProperty,\n  hexToBytes,\n  isObject,\n  isStrictHexString,\n  isValidHexAddress,\n  isValidJson,\n  remove0x,\n} from '@metamask/utils';\nimport { Mutex } from 'async-mutex';\nimport type { MutexInterface } from 'async-mutex';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\nimport type { Patch } from 'immer';\nimport { isEqual } from 'lodash';\n// When generating a ULID within the same millisecond, monotonicFactory provides some guarantees regarding sort order.\nimport { ulid } from 'ulid';\n\nimport { KeyringControllerError } from './constants';\nimport type {\n  Eip7702AuthorizationParams,\n  PersonalMessageParams,\n  TypedMessageParams,\n} from './types';\n\nconst name = 'KeyringController';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n  trezor = 'Trezor Hardware',\n  oneKey = 'OneKey Hardware',\n  ledger = 'Ledger Hardware',\n  lattice = 'Lattice Hardware',\n  snap = 'Snap Keyring',\n}\n\n/**\n * Custody keyring types are a special case, as they are not a single type\n * but they all start with the prefix \"Custody\".\n *\n * @param keyringType - The type of the keyring.\n * @returns Whether the keyring type is a custody keyring.\n */\nexport const isCustodyKeyring = (keyringType: string): boolean => {\n  return keyringType.startsWith('Custody');\n};\n\n/**\n * The KeyringController state\n */\nexport type KeyringControllerState = {\n  /**\n   * Encrypted array of serialized keyrings data.\n   */\n  vault?: string;\n  /**\n   * Whether the vault has been decrypted successfully and\n   * keyrings contained within are deserialized and available.\n   */\n  isUnlocked: boolean;\n  /**\n   * Representations of managed keyrings.\n   */\n  keyrings: KeyringObject[];\n  /**\n   * The encryption key derived from the password and used to encrypt\n   * the vault. This is only stored if the `cacheEncryptionKey` option\n   * is enabled.\n   */\n  encryptionKey?: string;\n  /**\n   * The salt used to derive the encryption key from the password.\n   */\n  encryptionSalt?: string;\n};\n\nexport type KeyringControllerMemState = Omit<\n  KeyringControllerState,\n  'vault' | 'encryptionKey' | 'encryptionSalt'\n>;\n\nexport type KeyringControllerGetStateAction = {\n  type: `${typeof name}:getState`;\n  handler: () => KeyringControllerState;\n};\n\nexport type KeyringControllerSignMessageAction = {\n  type: `${typeof name}:signMessage`;\n  handler: KeyringController['signMessage'];\n};\n\nexport type KeyringControllerSignEip7702AuthorizationAction = {\n  type: `${typeof name}:signEip7702Authorization`;\n  handler: KeyringController['signEip7702Authorization'];\n};\n\nexport type KeyringControllerSignPersonalMessageAction = {\n  type: `${typeof name}:signPersonalMessage`;\n  handler: KeyringController['signPersonalMessage'];\n};\n\nexport type KeyringControllerSignTypedMessageAction = {\n  type: `${typeof name}:signTypedMessage`;\n  handler: KeyringController['signTypedMessage'];\n};\n\nexport type KeyringControllerDecryptMessageAction = {\n  type: `${typeof name}:decryptMessage`;\n  handler: KeyringController['decryptMessage'];\n};\n\nexport type KeyringControllerGetEncryptionPublicKeyAction = {\n  type: `${typeof name}:getEncryptionPublicKey`;\n  handler: KeyringController['getEncryptionPublicKey'];\n};\n\nexport type KeyringControllerGetKeyringsByTypeAction = {\n  type: `${typeof name}:getKeyringsByType`;\n  handler: KeyringController['getKeyringsByType'];\n};\n\nexport type KeyringControllerGetKeyringForAccountAction = {\n  type: `${typeof name}:getKeyringForAccount`;\n  handler: KeyringController['getKeyringForAccount'];\n};\n\nexport type KeyringControllerGetAccountsAction = {\n  type: `${typeof name}:getAccounts`;\n  handler: KeyringController['getAccounts'];\n};\n\nexport type KeyringControllerPersistAllKeyringsAction = {\n  type: `${typeof name}:persistAllKeyrings`;\n  handler: KeyringController['persistAllKeyrings'];\n};\n\nexport type KeyringControllerPrepareUserOperationAction = {\n  type: `${typeof name}:prepareUserOperation`;\n  handler: KeyringController['prepareUserOperation'];\n};\n\nexport type KeyringControllerPatchUserOperationAction = {\n  type: `${typeof name}:patchUserOperation`;\n  handler: KeyringController['patchUserOperation'];\n};\n\nexport type KeyringControllerSignUserOperationAction = {\n  type: `${typeof name}:signUserOperation`;\n  handler: KeyringController['signUserOperation'];\n};\n\nexport type KeyringControllerAddNewAccountAction = {\n  type: `${typeof name}:addNewAccount`;\n  handler: KeyringController['addNewAccount'];\n};\n\nexport type KeyringControllerWithKeyringAction = {\n  type: `${typeof name}:withKeyring`;\n  handler: KeyringController['withKeyring'];\n};\n\nexport type KeyringControllerStateChangeEvent = {\n  type: `${typeof name}:stateChange`;\n  payload: [KeyringControllerState, Patch[]];\n};\n\nexport type KeyringControllerAccountRemovedEvent = {\n  type: `${typeof name}:accountRemoved`;\n  payload: [string];\n};\n\nexport type KeyringControllerLockEvent = {\n  type: `${typeof name}:lock`;\n  payload: [];\n};\n\nexport type KeyringControllerUnlockEvent = {\n  type: `${typeof name}:unlock`;\n  payload: [];\n};\n\nexport type KeyringControllerQRKeyringStateChangeEvent = {\n  type: `${typeof name}:qrKeyringStateChange`;\n  payload: [ReturnType<IQRKeyringState['getState']>];\n};\n\nexport type KeyringControllerActions =\n  | KeyringControllerGetStateAction\n  | KeyringControllerSignMessageAction\n  | KeyringControllerSignEip7702AuthorizationAction\n  | KeyringControllerSignPersonalMessageAction\n  | KeyringControllerSignTypedMessageAction\n  | KeyringControllerDecryptMessageAction\n  | KeyringControllerGetEncryptionPublicKeyAction\n  | KeyringControllerGetAccountsAction\n  | KeyringControllerGetKeyringsByTypeAction\n  | KeyringControllerGetKeyringForAccountAction\n  | KeyringControllerPersistAllKeyringsAction\n  | KeyringControllerPrepareUserOperationAction\n  | KeyringControllerPatchUserOperationAction\n  | KeyringControllerSignUserOperationAction\n  | KeyringControllerAddNewAccountAction\n  | KeyringControllerWithKeyringAction;\n\nexport type KeyringControllerEvents =\n  | KeyringControllerStateChangeEvent\n  | KeyringControllerLockEvent\n  | KeyringControllerUnlockEvent\n  | KeyringControllerAccountRemovedEvent\n  | KeyringControllerQRKeyringStateChangeEvent;\n\nexport type KeyringControllerMessenger = RestrictedMessenger<\n  typeof name,\n  KeyringControllerActions,\n  KeyringControllerEvents,\n  never,\n  never\n>;\n\nexport type KeyringControllerOptions = {\n  keyringBuilders?: { (): EthKeyring; type: string }[];\n  messenger: KeyringControllerMessenger;\n  state?: { vault?: string; keyringsMetadata?: KeyringMetadata[] };\n} & (\n  | {\n      cacheEncryptionKey: true;\n      encryptor?: ExportableKeyEncryptor;\n    }\n  | {\n      cacheEncryptionKey?: false;\n      encryptor?: GenericEncryptor | ExportableKeyEncryptor;\n    }\n);\n\n/**\n * A keyring object representation.\n */\nexport type KeyringObject = {\n  /**\n   * Accounts associated with the keyring.\n   */\n  accounts: string[];\n  /**\n   * Keyring type.\n   */\n  type: string;\n  /**\n   * Additional data associated with the keyring.\n   */\n  metadata: KeyringMetadata;\n};\n\n/**\n * Additional information related to a keyring.\n */\nexport type KeyringMetadata = {\n  /**\n   * Keyring ID\n   */\n  id: string;\n  /**\n   * Keyring name\n   */\n  name: string;\n};\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\n\n/**\n * The `signTypedMessage` version\n *\n * @see https://docs.metamask.io/guide/signing-data.html\n */\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n\n/**\n * A serialized keyring object.\n */\nexport type SerializedKeyring = {\n  type: string;\n  data: Json;\n  metadata?: KeyringMetadata;\n};\n\n/**\n * State/data that can be updated during a `withKeyring` operation.\n */\ntype SessionState = {\n  keyrings: SerializedKeyring[];\n  password?: string;\n};\n\n/**\n * A generic encryptor interface that supports encrypting and decrypting\n * serializable data with a password.\n */\nexport type GenericEncryptor = {\n  /**\n   * Encrypts the given object with the given password.\n   *\n   * @param password - The password to encrypt with.\n   * @param object - The object to encrypt.\n   * @returns The encrypted string.\n   */\n  encrypt: (password: string, object: Json) => Promise<string>;\n  /**\n   * Decrypts the given encrypted string with the given password.\n   *\n   * @param password - The password to decrypt with.\n   * @param encryptedString - The encrypted string to decrypt.\n   * @returns The decrypted object.\n   */\n  decrypt: (password: string, encryptedString: string) => Promise<unknown>;\n  /**\n   * Optional vault migration helper. Checks if the provided vault is up to date\n   * with the desired encryption algorithm.\n   *\n   * @param vault - The encrypted string to check.\n   * @param targetDerivationParams - The desired target derivation params.\n   * @returns The updated encrypted string.\n   */\n  isVaultUpdated?: (\n    vault: string,\n    targetDerivationParams?: encryptorUtils.KeyDerivationOptions,\n  ) => boolean;\n};\n\n/**\n * An encryptor interface that supports encrypting and decrypting\n * serializable data with a password, and exporting and importing keys.\n */\nexport type ExportableKeyEncryptor<EncryptionKey = unknown> =\n  GenericEncryptor & {\n    /**\n     * Encrypts the given object with the given encryption key.\n     *\n     * @param key - The encryption key to encrypt with.\n     * @param object - The object to encrypt.\n     * @returns The encryption result.\n     */\n    encryptWithKey: (\n      key: EncryptionKey,\n      object: Json,\n    ) => Promise<encryptorUtils.EncryptionResult>;\n    /**\n     * Encrypts the given object with the given password, and returns the\n     * encryption result and the exported key string.\n     *\n     * @param password - The password to encrypt with.\n     * @param object - The object to encrypt.\n     * @param salt - The optional salt to use for encryption.\n     * @returns The encrypted string and the exported key string.\n     */\n    encryptWithDetail: (\n      password: string,\n      object: Json,\n      salt?: string,\n    ) => Promise<encryptorUtils.DetailedEncryptionResult>;\n    /**\n     * Decrypts the given encrypted string with the given encryption key.\n     *\n     * @param key - The encryption key to decrypt with.\n     * @param encryptedString - The encrypted string to decrypt.\n     * @returns The decrypted object.\n     */\n    decryptWithKey: (\n      key: EncryptionKey,\n      encryptedString: string,\n    ) => Promise<unknown>;\n    /**\n     * Decrypts the given encrypted string with the given password, and returns\n     * the decrypted object and the salt and exported key string used for\n     * encryption.\n     *\n     * @param password - The password to decrypt with.\n     * @param encryptedString - The encrypted string to decrypt.\n     * @returns The decrypted object and the salt and exported key string used for\n     * encryption.\n     */\n    decryptWithDetail: (\n      password: string,\n      encryptedString: string,\n    ) => Promise<encryptorUtils.DetailedDecryptResult>;\n    /**\n     * Generates an encryption key from exported key string.\n     *\n     * @param key - The exported key string.\n     * @returns The encryption key.\n     */\n    importKey: (key: string) => Promise<EncryptionKey>;\n  };\n\nexport type KeyringSelector =\n  | {\n      type: string;\n      index?: number;\n    }\n  | {\n      address: Hex;\n    }\n  | {\n      id: string;\n    };\n\n/**\n * A function executed within a mutually exclusive lock, with\n * a mutex releaser in its option bag.\n *\n * @param releaseLock - A function to release the lock.\n */\ntype MutuallyExclusiveCallback<Result> = ({\n  releaseLock,\n}: {\n  releaseLock: MutexInterface.Releaser;\n}) => Promise<Result>;\n\n/**\n * Get builder function for `Keyring`\n *\n * Returns a builder function for `Keyring` with a `type` property.\n *\n * @param KeyringConstructor - The Keyring class for the builder.\n * @returns A builder function for the given Keyring.\n */\nexport function keyringBuilderFactory(KeyringConstructor: KeyringClass) {\n  const builder = () => new KeyringConstructor();\n\n  builder.type = KeyringConstructor.type;\n\n  return builder;\n}\n\nconst defaultKeyringBuilders = [\n  // todo: keyring types are mismatched, this should be fixed in they keyrings themselves\n  // @ts-expect-error keyring types are mismatched\n  keyringBuilderFactory(SimpleKeyring),\n  // @ts-expect-error keyring types are mismatched\n  keyringBuilderFactory(HdKeyring),\n];\n\nexport const getDefaultKeyringState = (): KeyringControllerState => {\n  return {\n    isUnlocked: false,\n    keyrings: [],\n  };\n};\n\n/**\n * Assert that the given keyring has an exportable\n * mnemonic.\n *\n * @param keyring - The keyring to check\n * @throws When the keyring does not have a mnemonic\n */\nfunction assertHasUint8ArrayMnemonic(\n  keyring: EthKeyring,\n): asserts keyring is EthKeyring & { mnemonic: Uint8Array } {\n  if (\n    !(\n      hasProperty(keyring, 'mnemonic') && keyring.mnemonic instanceof Uint8Array\n    )\n  ) {\n    throw new Error(\"Can't get mnemonic bytes from keyring\");\n  }\n}\n\n/**\n * Assert that the provided encryptor supports\n * encryption and encryption key export.\n *\n * @param encryptor - The encryptor to check.\n * @throws If the encryptor does not support key encryption.\n */\nfunction assertIsExportableKeyEncryptor(\n  encryptor: GenericEncryptor | ExportableKeyEncryptor,\n): asserts encryptor is ExportableKeyEncryptor {\n  if (\n    !(\n      'importKey' in encryptor &&\n      typeof encryptor.importKey === 'function' &&\n      'decryptWithKey' in encryptor &&\n      typeof encryptor.decryptWithKey === 'function' &&\n      'encryptWithKey' in encryptor &&\n      typeof encryptor.encryptWithKey === 'function'\n    )\n  ) {\n    throw new Error(KeyringControllerError.UnsupportedEncryptionKeyExport);\n  }\n}\n\n/**\n * Assert that the provided password is a valid non-empty string.\n *\n * @param password - The password to check.\n * @throws If the password is not a valid string.\n */\nfunction assertIsValidPassword(password: unknown): asserts password is string {\n  if (typeof password !== 'string') {\n    throw new Error(KeyringControllerError.WrongPasswordType);\n  }\n\n  if (!password || !password.length) {\n    throw new Error(KeyringControllerError.InvalidEmptyPassword);\n  }\n}\n\n/**\n * Assert that the provided encryption key is a valid non-empty string.\n *\n * @param encryptionKey - The encryption key to check.\n * @throws If the encryption key is not a valid string.\n */\nfunction assertIsEncryptionKeySet(\n  encryptionKey: string | undefined,\n): asserts encryptionKey is string {\n  if (!encryptionKey) {\n    throw new Error(KeyringControllerError.EncryptionKeyNotSet);\n  }\n}\n\n/**\n * Checks if the provided value is a serialized keyrings array.\n *\n * @param array - The value to check.\n * @returns True if the value is a serialized keyrings array.\n */\nfunction isSerializedKeyringsArray(\n  array: unknown,\n): array is SerializedKeyring[] {\n  return (\n    typeof array === 'object' &&\n    Array.isArray(array) &&\n    array.every((value) => value.type && isValidJson(value.data))\n  );\n}\n\n/**\n * Display For Keyring\n *\n * Is used for adding the current keyrings to the state object.\n *\n * @param keyringWithMetadata - The keyring and its metadata.\n * @param keyringWithMetadata.keyring - The keyring to display.\n * @param keyringWithMetadata.metadata - The metadata of the keyring.\n * @returns A keyring display object, with type and accounts properties.\n */\nasync function displayForKeyring({\n  keyring,\n  metadata,\n}: {\n  keyring: EthKeyring;\n  metadata: KeyringMetadata;\n}): Promise<KeyringObject> {\n  const accounts = await keyring.getAccounts();\n\n  return {\n    type: keyring.type,\n    // Cast to `string[]` here is safe here because `accounts` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    accounts: accounts.map(normalize) as string[],\n    metadata,\n  };\n}\n\n/**\n * Check if address is an ethereum address\n *\n * @param address - An address.\n * @returns Returns true if the address is an ethereum one, false otherwise.\n */\nfunction isEthAddress(address: string): boolean {\n  // We first check if it's a matching `Hex` string, so that is narrows down\n  // `address` as an `Hex` type, allowing us to use `isValidHexAddress`\n  return (\n    // NOTE: This function only checks for lowercased strings\n    isStrictHexString(address.toLowerCase()) &&\n    // This checks for lowercased addresses and checksum addresses too\n    isValidHexAddress(address as Hex)\n  );\n}\n\n/**\n * Normalize ethereum or non-EVM address.\n *\n * @param address - Ethereum or non-EVM address.\n * @returns The normalized address.\n */\nfunction normalize(address: string): string | undefined {\n  // Since the `KeyringController` is only dealing with address, we have\n  // no other way to get the associated account type with this address. So we\n  // are down to check the actual address format for now\n  // TODO: Find a better way to not have those runtime checks based on the\n  //       address value!\n  return isEthAddress(address) ? ethNormalize(address) : address;\n}\n\n/**\n * Controller responsible for establishing and managing user identity.\n *\n * This class is a wrapper around the `eth-keyring-controller` package. The\n * `eth-keyring-controller` manages the \"vault\", which is an encrypted store of private keys, and\n * it manages the wallet \"lock\" state. This wrapper class has convenience methods for interacting\n * with the internal keyring controller and handling certain complex operations that involve the\n * keyrings.\n */\nexport class KeyringController extends BaseController<\n  typeof name,\n  KeyringControllerState,\n  KeyringControllerMessenger\n> {\n  readonly #controllerOperationMutex = new Mutex();\n\n  readonly #vaultOperationMutex = new Mutex();\n\n  readonly #keyringBuilders: { (): EthKeyring; type: string }[];\n\n  readonly #encryptor: GenericEncryptor | ExportableKeyEncryptor;\n\n  readonly #cacheEncryptionKey: boolean;\n\n  #keyrings: { keyring: EthKeyring; metadata: KeyringMetadata }[];\n\n  #unsupportedKeyrings: SerializedKeyring[];\n\n  #password?: string;\n\n  #qrKeyringStateListener?: (\n    state: ReturnType<IQRKeyringState['getState']>,\n  ) => void;\n\n  /**\n   * Creates a KeyringController instance.\n   *\n   * @param options - Initial options used to configure this controller\n   * @param options.encryptor - An optional object for defining encryption schemes.\n   * @param options.keyringBuilders - Set a new name for account.\n   * @param options.cacheEncryptionKey - Whether to cache or not encryption key.\n   * @param options.messenger - A restricted messenger.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor(options: KeyringControllerOptions) {\n    const {\n      encryptor = encryptorUtils,\n      keyringBuilders,\n      messenger,\n      state,\n    } = options;\n\n    super({\n      name,\n      metadata: {\n        vault: { persist: true, anonymous: false },\n        isUnlocked: { persist: false, anonymous: true },\n        keyrings: { persist: false, anonymous: false },\n        encryptionKey: { persist: false, anonymous: false },\n        encryptionSalt: { persist: false, anonymous: false },\n      },\n      messenger,\n      state: {\n        ...getDefaultKeyringState(),\n        ...state,\n      },\n    });\n\n    this.#keyringBuilders = keyringBuilders\n      ? keyringBuilders.concat(defaultKeyringBuilders)\n      : defaultKeyringBuilders;\n\n    this.#encryptor = encryptor;\n    this.#keyrings = [];\n    this.#unsupportedKeyrings = [];\n\n    // This option allows the controller to cache an exported key\n    // for use in decrypting and encrypting data without password\n    this.#cacheEncryptionKey = Boolean(options.cacheEncryptionKey);\n    if (this.#cacheEncryptionKey) {\n      assertIsExportableKeyEncryptor(encryptor);\n    }\n\n    this.#registerMessageHandlers();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @param accountCount - Number of accounts before adding a new one, used to\n   * make the method idempotent.\n   * @returns Promise resolving to the added account address.\n   */\n  async addNewAccount(accountCount?: number): Promise<string> {\n    this.#assertIsUnlocked();\n\n    return this.#persistOrRollback(async () => {\n      const primaryKeyring = this.getKeyringsByType('HD Key Tree')[0] as\n        | EthKeyring\n        | undefined;\n      if (!primaryKeyring) {\n        throw new Error('No HD keyring found');\n      }\n      const oldAccounts = await primaryKeyring.getAccounts();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n        // we return the account already existing at index `accountCount`\n        const existingAccount = oldAccounts[accountCount];\n\n        if (!existingAccount) {\n          throw new Error(`Can't find account at index ${accountCount}`);\n        }\n\n        return existingAccount;\n      }\n\n      const [addedAccountAddress] = await primaryKeyring.addAccounts(1);\n      await this.#verifySeedPhrase();\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Adds a new account to the specified keyring.\n   *\n   * @param keyring - Keyring to add the account to.\n   * @param accountCount - Number of accounts before adding a new one, used to make the method idempotent.\n   * @returns Promise resolving to the added account address\n   */\n  async addNewAccountForKeyring(\n    keyring: EthKeyring,\n    accountCount?: number,\n  ): Promise<Hex> {\n    // READ THIS CAREFULLY:\n    // We still uses `Hex` here, since we are not using this method when creating\n    // and account using a \"Snap Keyring\". This function assume the `keyring` is\n    // ethereum compatible, but \"Snap Keyring\" might not be.\n    this.#assertIsUnlocked();\n\n    return this.#persistOrRollback(async () => {\n      const oldAccounts = await this.#getAccountsFromKeyrings();\n\n      if (accountCount && oldAccounts.length !== accountCount) {\n        if (accountCount > oldAccounts.length) {\n          throw new Error('Account out of sequence');\n        }\n\n        const existingAccount = oldAccounts[accountCount];\n        assertIsStrictHexString(existingAccount);\n\n        return existingAccount;\n      }\n\n      await keyring.addAccounts(1);\n\n      const addedAccountAddress = (await this.#getAccountsFromKeyrings()).find(\n        (selectedAddress) => !oldAccounts.includes(selectedAddress),\n      );\n      assertIsStrictHexString(addedAccountAddress);\n\n      return addedAccountAddress;\n    });\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase as Uint8Array,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndRestore(\n    password: string,\n    seed: Uint8Array,\n  ): Promise<void> {\n    return this.#persistOrRollback(async () => {\n      assertIsValidPassword(password);\n\n      await this.#createNewVaultWithKeyring(password, {\n        type: KeyringTypes.hd,\n        opts: {\n          mnemonic: seed,\n          numberOfAccounts: 1,\n        },\n      });\n    });\n  }\n\n  /**\n   * Create a new vault and primary keyring.\n   *\n   * This only works if keyrings are empty. If there is a pre-existing unlocked vault, calling this will have no effect.\n   * If there is a pre-existing locked vault, it will be replaced.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Promise resolving when the operation ends successfully.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    return this.#persistOrRollback(async () => {\n      const accounts = await this.#getAccountsFromKeyrings();\n      if (!accounts.length) {\n        await this.#createNewVaultWithKeyring(password, {\n          type: KeyringTypes.hd,\n        });\n      }\n    });\n  }\n\n  /**\n   * Adds a new keyring of the given `type`.\n   *\n   * @param type - Keyring type name.\n   * @param opts - Keyring options.\n   * @throws If a builder for the given `type` does not exist.\n   * @returns Promise resolving to the new keyring metadata.\n   */\n  async addNewKeyring(\n    type: KeyringTypes | string,\n    opts?: unknown,\n  ): Promise<KeyringMetadata> {\n    this.#assertIsUnlocked();\n\n    if (type === KeyringTypes.qr) {\n      return this.#getKeyringMetadata(await this.getOrAddQRKeyring());\n    }\n\n    return this.#getKeyringMetadata(\n      await this.#persistOrRollback(async () => this.#newKeyring(type, opts)),\n    );\n  }\n\n  /**\n   * Method to verify a given password validity. Throws an\n   * error if the password is invalid.\n   *\n   * @param password - Password of the keyring.\n   */\n  async verifyPassword(password: string) {\n    if (!this.state.vault) {\n      throw new Error(KeyringControllerError.VaultError);\n    }\n    await this.#encryptor.decrypt(password, this.state.vault);\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.state.isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @param keyringId - The id of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  async exportSeedPhrase(\n    password: string,\n    keyringId?: string,\n  ): Promise<Uint8Array> {\n    this.#assertIsUnlocked();\n    await this.verifyPassword(password);\n    const selectedKeyring = this.#getKeyringByIdOrDefault(keyringId);\n    if (!selectedKeyring) {\n      throw new Error('Keyring not found');\n    }\n    assertHasUint8ArrayMnemonic(selectedKeyring);\n\n    return selectedKeyring.mnemonic;\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  async exportAccount(password: string, address: string): Promise<string> {\n    await this.verifyPassword(password);\n\n    const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n    if (!keyring.exportAccount) {\n      throw new Error(KeyringControllerError.UnsupportedExportAccount);\n    }\n\n    return await keyring.exportAccount(normalize(address) as Hex);\n  }\n\n  /**\n   * Returns the public addresses of all accounts from every keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  async getAccounts(): Promise<string[]> {\n    this.#assertIsUnlocked();\n    return this.state.keyrings.reduce<string[]>(\n      (accounts, keyring) => accounts.concat(keyring.accounts),\n      [],\n    );\n  }\n\n  /**\n   * Get encryption public key.\n   *\n   * @param account - An account address.\n   * @param opts - Additional encryption options.\n   * @throws If the `account` does not exist or does not support the `getEncryptionPublicKey` method\n   * @returns Promise resolving to encyption public key of the `account` if one exists.\n   */\n  async getEncryptionPublicKey(\n    account: string,\n    opts?: Record<string, unknown>,\n  ): Promise<string> {\n    this.#assertIsUnlocked();\n    const address = ethNormalize(account) as Hex;\n    const keyring = (await this.getKeyringForAccount(account)) as EthKeyring;\n    if (!keyring.getEncryptionPublicKey) {\n      throw new Error(KeyringControllerError.UnsupportedGetEncryptionPublicKey);\n    }\n\n    return await keyring.getEncryptionPublicKey(address, opts);\n  }\n\n  /**\n   * Attempts to decrypt the provided message parameters.\n   *\n   * @param messageParams - The decryption message parameters.\n   * @param messageParams.from - The address of the account you want to use to decrypt the message.\n   * @param messageParams.data - The encrypted data that you want to decrypt.\n   * @returns The raw decryption result.\n   */\n  async decryptMessage(messageParams: {\n    from: string;\n    data: Eip1024EncryptedData;\n  }): Promise<string> {\n    this.#assertIsUnlocked();\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n    if (!keyring.decryptMessage) {\n      throw new Error(KeyringControllerError.UnsupportedDecryptMessage);\n    }\n\n    return keyring.decryptMessage(address, messageParams.data);\n  }\n\n  /**\n   * Returns the currently initialized keyring that manages\n   * the specified `address` if one exists.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param account - An account address.\n   * @returns Promise resolving to keyring of the `account` if one exists.\n   */\n  async getKeyringForAccount(account: string): Promise<unknown> {\n    this.#assertIsUnlocked();\n    const address = normalize(account);\n\n    const candidates = await Promise.all(\n      this.#keyrings.map(async ({ keyring }) => {\n        return Promise.all([keyring, keyring.getAccounts()]);\n      }),\n    );\n\n    const winners = candidates.filter((candidate) => {\n      const accounts = candidate[1].map(normalize);\n      return accounts.includes(address);\n    });\n\n    if (winners.length && winners[0]?.length) {\n      return winners[0][0];\n    }\n\n    // Adding more info to the error\n    let errorInfo = '';\n    if (!candidates.length) {\n      errorInfo = 'There are no keyrings';\n    } else if (!winners.length) {\n      errorInfo = 'There are keyrings, but none match the address';\n    }\n    throw new Error(\n      `${KeyringControllerError.NoKeyring}. Error info: ${errorInfo}`,\n    );\n  }\n\n  /**\n   * Returns all keyrings of the given type.\n   *\n   * @deprecated Use of this method is discouraged as actions executed directly on\n   * keyrings are not being reflected in the KeyringController state and not\n   * persisted in the vault. Use `withKeyring` instead.\n   * @param type - Keyring type name.\n   * @returns An array of keyrings of the given type.\n   */\n  getKeyringsByType(type: KeyringTypes | string): unknown[] {\n    this.#assertIsUnlocked();\n    return this.#keyrings\n      .filter(({ keyring }) => keyring.type === type)\n      .map(({ keyring }) => keyring);\n  }\n\n  /**\n   * Persist all serialized keyrings in the vault.\n   *\n   * @deprecated This method is being phased out in favor of `withKeyring`.\n   * @returns Promise resolving with `true` value when the\n   * operation completes.\n   */\n  async persistAllKeyrings(): Promise<boolean> {\n    return this.#withRollback(async () => {\n      this.#assertIsUnlocked();\n\n      await this.#updateVault();\n      return true;\n    });\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to the imported account address.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    // TODO: Replace `any` with type\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    args: any[],\n  ): Promise<string> {\n    this.#assertIsUnlocked();\n    return this.#persistOrRollback(async () => {\n      let privateKey;\n      switch (strategy) {\n        case AccountImportStrategy.privateKey:\n          const [importedKey] = args;\n          if (!importedKey) {\n            throw new Error('Cannot import an empty key.');\n          }\n          const prefixed = add0x(importedKey);\n\n          let bufferedPrivateKey;\n          try {\n            bufferedPrivateKey = hexToBytes(prefixed);\n          } catch {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          if (\n            !isValidPrivate(bufferedPrivateKey) ||\n            // ensures that the key is 64 bytes long\n            getBinarySize(prefixed) !== 64 + '0x'.length\n          ) {\n            throw new Error('Cannot import invalid private key.');\n          }\n\n          privateKey = remove0x(prefixed);\n          break;\n        case AccountImportStrategy.json:\n          let wallet;\n          const [input, password] = args;\n          try {\n            wallet = importers.fromEtherWallet(input, password);\n          } catch (e) {\n            wallet = wallet || (await Wallet.fromV3(input, password, true));\n          }\n          privateKey = bytesToHex(wallet.getPrivateKey());\n          break;\n        default:\n          throw new Error(`Unexpected import strategy: '${String(strategy)}'`);\n      }\n      const newKeyring = (await this.#newKeyring(KeyringTypes.simple, [\n        privateKey,\n      ])) as EthKeyring;\n      const accounts = await newKeyring.getAccounts();\n      return accounts[0];\n    });\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @fires KeyringController:accountRemoved\n   * @returns Promise resolving when the account is removed.\n   */\n  async removeAccount(address: string): Promise<void> {\n    this.#assertIsUnlocked();\n\n    await this.#persistOrRollback(async () => {\n      const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n\n      const keyringIndex = this.state.keyrings.findIndex((kr) =>\n        kr.accounts.includes(address),\n      );\n\n      const isPrimaryKeyring = keyringIndex === 0;\n      const shouldRemoveKeyring = (await keyring.getAccounts()).length === 1;\n\n      // Primary keyring should never be removed, so we need to keep at least one account in it\n      if (isPrimaryKeyring && shouldRemoveKeyring) {\n        throw new Error(KeyringControllerError.LastAccountInPrimaryKeyring);\n      }\n\n      // Not all the keyrings support this, so we have to check\n      if (!keyring.removeAccount) {\n        throw new Error(KeyringControllerError.UnsupportedRemoveAccount);\n      }\n\n      // The `removeAccount` method of snaps keyring is async. We have to update\n      // the interface of the other keyrings to be async as well.\n      // FIXME: We do cast to `Hex` to makes the type checker happy here, and\n      // because `Keyring<State>.removeAccount` requires address to be `Hex`. Those\n      // type would need to be updated for a full non-EVM support.\n      keyring.removeAccount(address as Hex);\n\n      if (shouldRemoveKeyring) {\n        await this.#removeEmptyKeyrings();\n      }\n    });\n\n    this.messagingSystem.publish(`${name}:accountRemoved`, address);\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving when the operation completes.\n   */\n  async setLocked(): Promise<void> {\n    this.#assertIsUnlocked();\n\n    return this.#withRollback(async () => {\n      this.#unsubscribeFromQRKeyringsEvents();\n\n      this.#password = undefined;\n      await this.#clearKeyrings();\n\n      this.update((state) => {\n        state.isUnlocked = false;\n        state.keyrings = [];\n        delete state.encryptionKey;\n        delete state.encryptionSalt;\n      });\n\n      this.messagingSystem.publish(`${name}:lock`);\n    });\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signMessage(messageParams: PersonalMessageParams): Promise<string> {\n    this.#assertIsUnlocked();\n\n    if (!messageParams.data) {\n      throw new Error(\"Can't sign an empty message\");\n    }\n\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n    if (!keyring.signMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignMessage);\n    }\n\n    return await keyring.signMessage(address, messageParams.data);\n  }\n\n  /**\n   * Signs EIP-7702 Authorization message by calling down into a specific keyring.\n   *\n   * @param params - EIP7702AuthorizationParams object to sign.\n   * @returns Promise resolving to an EIP-7702 Authorization signature.\n   * @throws Will throw UnsupportedSignEIP7702Authorization if the keyring does not support signing EIP-7702 Authorization messages.\n   */\n  async signEip7702Authorization(\n    params: Eip7702AuthorizationParams,\n  ): Promise<string> {\n    const from = ethNormalize(params.from) as Hex;\n\n    const keyring = (await this.getKeyringForAccount(from)) as EthKeyring;\n\n    if (!keyring.signEip7702Authorization) {\n      throw new Error(\n        KeyringControllerError.UnsupportedSignEip7702Authorization,\n      );\n    }\n\n    const { chainId, nonce } = params;\n    const contractAddress = ethNormalize(params.contractAddress) as\n      | Hex\n      | undefined;\n\n    if (contractAddress === undefined) {\n      throw new Error(\n        KeyringControllerError.MissingEip7702AuthorizationContractAddress,\n      );\n    }\n\n    return await keyring.signEip7702Authorization(from, [\n      chainId,\n      contractAddress,\n      nonce,\n    ]);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  async signPersonalMessage(messageParams: PersonalMessageParams) {\n    this.#assertIsUnlocked();\n    const address = ethNormalize(messageParams.from) as Hex;\n    const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n    if (!keyring.signPersonalMessage) {\n      throw new Error(KeyringControllerError.UnsupportedSignPersonalMessage);\n    }\n\n    const normalizedData = normalize(messageParams.data) as Hex;\n\n    return await keyring.signPersonalMessage(address, normalizedData);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(\n    messageParams: TypedMessageParams,\n    version: SignTypedDataVersion,\n  ): Promise<string> {\n    this.#assertIsUnlocked();\n\n    try {\n      if (\n        ![\n          SignTypedDataVersion.V1,\n          SignTypedDataVersion.V3,\n          SignTypedDataVersion.V4,\n        ].includes(version)\n      ) {\n        throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n\n      // Cast to `Hex` here is safe here because `messageParams.from` is not nullish.\n      // `normalize` returns `Hex` unless given a nullish value.\n      const address = ethNormalize(messageParams.from) as Hex;\n      const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n      if (!keyring.signTypedData) {\n        throw new Error(KeyringControllerError.UnsupportedSignTypedMessage);\n      }\n\n      return await keyring.signTypedData(\n        address,\n        version !== SignTypedDataVersion.V1 &&\n          typeof messageParams.data === 'string'\n          ? JSON.parse(messageParams.data)\n          : messageParams.data,\n        { version },\n      );\n    } catch (error) {\n      // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @param opts - An optional options object.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  async signTransaction(\n    transaction: TypedTransaction,\n    from: string,\n    opts?: Record<string, unknown>,\n  ): Promise<TypedTxData> {\n    this.#assertIsUnlocked();\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n    if (!keyring.signTransaction) {\n      throw new Error(KeyringControllerError.UnsupportedSignTransaction);\n    }\n\n    return await keyring.signTransaction(address, transaction, opts);\n  }\n\n  /**\n   * Convert a base transaction to a base UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param transactions - Base transactions to include in the UserOperation.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A pseudo-UserOperation that can be used to construct a real.\n   */\n  async prepareUserOperation(\n    from: string,\n    transactions: EthBaseTransaction[],\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthBaseUserOperation> {\n    this.#assertIsUnlocked();\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n\n    if (!keyring.prepareUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPrepareUserOperation);\n    }\n\n    return await keyring.prepareUserOperation(\n      address,\n      transactions,\n      executionContext,\n    );\n  }\n\n  /**\n   * Patches properties of a UserOperation. Currently, only the\n   * `paymasterAndData` can be patched.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to patch.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns A patch to apply to the UserOperation.\n   */\n  async patchUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<EthUserOperationPatch> {\n    this.#assertIsUnlocked();\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n\n    if (!keyring.patchUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedPatchUserOperation);\n    }\n\n    return await keyring.patchUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Signs an UserOperation.\n   *\n   * @param from - Address of the sender.\n   * @param userOp - UserOperation to sign.\n   * @param executionContext - The execution context to use for the UserOperation.\n   * @returns The signature of the UserOperation.\n   */\n  async signUserOperation(\n    from: string,\n    userOp: EthUserOperation,\n    executionContext: KeyringExecutionContext,\n  ): Promise<string> {\n    this.#assertIsUnlocked();\n    const address = ethNormalize(from) as Hex;\n    const keyring = (await this.getKeyringForAccount(address)) as EthKeyring;\n\n    if (!keyring.signUserOperation) {\n      throw new Error(KeyringControllerError.UnsupportedSignUserOperation);\n    }\n\n    return await keyring.signUserOperation(address, userOp, executionContext);\n  }\n\n  /**\n   * Changes the password used to encrypt the vault.\n   *\n   * @param password - The new password.\n   * @returns Promise resolving when the operation completes.\n   */\n  changePassword(password: string): Promise<void> {\n    this.#assertIsUnlocked();\n\n    // If the password is the same, do nothing.\n    if (this.#password === password) {\n      return Promise.resolve();\n    }\n\n    return this.#persistOrRollback(async () => {\n      assertIsValidPassword(password);\n\n      this.#password = password;\n      // We need to clear encryption key and salt from state\n      // to force the controller to re-encrypt the vault using\n      // the new password.\n      if (this.#cacheEncryptionKey) {\n        this.update((state) => {\n          delete state.encryptionKey;\n          delete state.encryptionSalt;\n        });\n      }\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings, using the\n   * given encryption key and salt. The optional salt can be used to check for\n   * consistency with the vault salt.\n   *\n   * @param encryptionKey - Key to unlock the keychain.\n   * @param encryptionSalt - Optional salt to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitEncryptionKey(\n    encryptionKey: string,\n    encryptionSalt?: string,\n  ): Promise<void> {\n    const { newMetadata } = await this.#withRollback(async () => {\n      const result = await this.#unlockKeyrings(\n        undefined,\n        encryptionKey,\n        encryptionSalt,\n      );\n      this.#setUnlocked();\n      return result;\n    });\n\n    try {\n      // if new metadata has been generated during login, we\n      // can attempt to upgrade the vault.\n      await this.#withRollback(async () => {\n        if (newMetadata) {\n          await this.#updateVault();\n        }\n      });\n    } catch (error) {\n      // We don't want to throw an error if the upgrade fails\n      // since the controller is already unlocked.\n      console.error('Failed to update vault during login:', error);\n    }\n  }\n\n  /**\n   * Exports the vault encryption key.\n   *\n   * @returns The vault encryption key.\n   */\n  async exportEncryptionKey(): Promise<string> {\n    this.#assertIsUnlocked();\n\n    return await this.#withControllerLock(async () => {\n      const { encryptionKey } = this.state;\n      assertIsEncryptionKeySet(encryptionKey);\n\n      return encryptionKey;\n    });\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings,\n   * using the given password.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving when the operation completes.\n   */\n  async submitPassword(password: string): Promise<void> {\n    const { newMetadata } = await this.#withRollback(async () => {\n      const result = await this.#unlockKeyrings(password);\n      this.#setUnlocked();\n      return result;\n    });\n\n    try {\n      // If there are stronger encryption params available, or\n      // if new metadata has been generated during login, we\n      // can attempt to upgrade the vault.\n      await this.#withRollback(async () => {\n        if (newMetadata || this.#isNewEncryptionAvailable()) {\n          await this.#updateVault();\n        }\n      });\n    } catch (error) {\n      // We don't want to throw an error if the upgrade fails\n      // since the controller is already unlocked.\n      console.error('Failed to update vault during login:', error);\n    }\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @param keyringId - The id of the keyring to verify.\n   * @returns Promise resolving to the seed phrase as Uint8Array.\n   */\n  async verifySeedPhrase(keyringId?: string): Promise<Uint8Array> {\n    this.#assertIsUnlocked();\n\n    return this.#withControllerLock(async () =>\n      this.#verifySeedPhrase(keyringId),\n    );\n  }\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @param options - Additional options.\n   * @param options.createIfMissing - Whether to create a new keyring if the selected one is missing.\n   * @param options.createWithData - Optional data to use when creating a new keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   * @deprecated This method overload is deprecated. Use `withKeyring` without options instead.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring = EthKeyring,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: ({\n      keyring,\n      metadata,\n    }: {\n      keyring: SelectedKeyring;\n      metadata: KeyringMetadata;\n    }) => Promise<CallbackResult>,\n    // eslint-disable-next-line @typescript-eslint/unified-signatures\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown },\n  ): Promise<CallbackResult>;\n\n  /**\n   * Select a keyring and execute the given operation with\n   * the selected keyring, as a mutually exclusive atomic\n   * operation.\n   *\n   * The method automatically persists changes at the end of the\n   * function execution, or rolls back the changes if an error\n   * is thrown.\n   *\n   * @param selector - Keyring selector object.\n   * @param operation - Function to execute with the selected keyring.\n   * @returns Promise resolving to the result of the function execution.\n   * @template SelectedKeyring - The type of the selected keyring.\n   * @template CallbackResult - The type of the value resolved by the callback function.\n   */\n  async withKeyring<\n    SelectedKeyring extends EthKeyring = EthKeyring,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: ({\n      keyring,\n      metadata,\n    }: {\n      keyring: SelectedKeyring;\n      metadata: KeyringMetadata;\n    }) => Promise<CallbackResult>,\n  ): Promise<CallbackResult>;\n\n  async withKeyring<\n    SelectedKeyring extends EthKeyring = EthKeyring,\n    CallbackResult = void,\n  >(\n    selector: KeyringSelector,\n    operation: ({\n      keyring,\n      metadata,\n    }: {\n      keyring: SelectedKeyring;\n      metadata: KeyringMetadata;\n    }) => Promise<CallbackResult>,\n    options:\n      | { createIfMissing?: false }\n      | { createIfMissing: true; createWithData?: unknown } = {\n      createIfMissing: false,\n    },\n  ): Promise<CallbackResult> {\n    this.#assertIsUnlocked();\n\n    return this.#persistOrRollback(async () => {\n      let keyring: SelectedKeyring | undefined;\n\n      if ('address' in selector) {\n        keyring = (await this.getKeyringForAccount(selector.address)) as\n          | SelectedKeyring\n          | undefined;\n      } else if ('type' in selector) {\n        keyring = this.getKeyringsByType(selector.type)[selector.index || 0] as\n          | SelectedKeyring\n          | undefined;\n\n        if (!keyring && options.createIfMissing) {\n          keyring = (await this.#newKeyring(\n            selector.type,\n            options.createWithData,\n          )) as SelectedKeyring;\n        }\n      } else if ('id' in selector) {\n        keyring = this.#getKeyringById(selector.id) as SelectedKeyring;\n      }\n\n      if (!keyring) {\n        throw new Error(KeyringControllerError.KeyringNotFound);\n      }\n\n      const result = await operation({\n        keyring,\n        metadata: this.#getKeyringMetadata(keyring),\n      });\n\n      if (Object.is(result, keyring)) {\n        // Access to a keyring instance outside of controller safeguards\n        // should be discouraged, as it can lead to unexpected behavior.\n        // This error is thrown to prevent consumers using `withKeyring`\n        // as a way to get a reference to a keyring instance.\n        throw new Error(KeyringControllerError.UnsafeDirectKeyringAccess);\n      }\n\n      return result;\n    });\n  }\n\n  // QR Hardware related methods\n\n  /**\n   * Get QR Hardware keyring.\n   *\n   * @returns The QR Keyring if defined, otherwise undefined\n   * @deprecated Use `withKeyring` instead.\n   */\n  getQRKeyring(): QRKeyring | undefined {\n    this.#assertIsUnlocked();\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return this.getKeyringsByType(KeyringTypes.qr)[0] as unknown as QRKeyring;\n  }\n\n  /**\n   * Get QR hardware keyring. If it doesn't exist, add it.\n   *\n   * @returns The added keyring\n   * @deprecated Use `addNewKeyring` and `withKeyring` instead.\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    this.#assertIsUnlocked();\n\n    return (\n      this.getQRKeyring() ||\n      (await this.#persistOrRollback(async () => this.#addQRKeyring()))\n    );\n  }\n\n  /**\n   * Restore QR keyring from serialized data.\n   *\n   * @param serialized - Serialized data to restore the keyring from.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  // TODO: Replace `any` with type\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    this.#assertIsUnlocked();\n\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n      keyring.deserialize(serialized);\n    });\n  }\n\n  /**\n   * Reset QR keyring state.\n   *\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async resetQRKeyringState(): Promise<void> {\n    this.#assertIsUnlocked();\n\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  /**\n   * Get QR keyring state.\n   *\n   * @returns Promise resolving to the keyring state.\n   * @deprecated Use `withKeyring` or subscribe to `\"KeyringController:qrKeyringStateChange\"`\n   * instead.\n   */\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    this.#assertIsUnlocked();\n\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  /**\n   * Submit QR hardware wallet public HDKey.\n   *\n   * @param cryptoHDKey - The key to submit.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    this.#assertIsUnlocked();\n\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  /**\n   * Submit QR hardware wallet account.\n   *\n   * @param cryptoAccount - The account to submit.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    this.#assertIsUnlocked();\n\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  /**\n   * Submit QR hardware wallet signature.\n   *\n   * @param requestId - The request ID.\n   * @param ethSignature - The signature to submit.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async submitQRSignature(\n    requestId: string,\n    ethSignature: string,\n  ): Promise<void> {\n    this.#assertIsUnlocked();\n\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  /**\n   * Cancel QR sign request.\n   *\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async cancelQRSignRequest(): Promise<void> {\n    this.#assertIsUnlocked();\n\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  /**\n   * Cancels qr keyring sync.\n   *\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async cancelQRSynchronization(): Promise<void> {\n    this.#assertIsUnlocked();\n\n    (await this.getOrAddQRKeyring()).cancelSync();\n  }\n\n  /**\n   * Connect to QR hardware wallet.\n   *\n   * @param page - The page to connect to.\n   * @returns Promise resolving to the connected accounts.\n   * @deprecated Use of this method is discouraged as it creates a dangling promise\n   * internal to the `QRKeyring`, which can lead to unpredictable deadlocks. Please use\n   * `withKeyring` instead.\n   */\n  async connectQRHardware(\n    page: number,\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    this.#assertIsUnlocked();\n\n    return this.#persistOrRollback(async () => {\n      try {\n        const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n        let accounts;\n        switch (page) {\n          case -1:\n            accounts = await keyring.getPreviousPage();\n            break;\n          case 1:\n            accounts = await keyring.getNextPage();\n            break;\n          default:\n            accounts = await keyring.getFirstPage();\n        }\n        // TODO: Replace `any` with type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return accounts.map((account: any) => {\n          return {\n            ...account,\n            balance: '0x0',\n          };\n        });\n      } catch (e) {\n        // TODO: Add test case for when keyring throws\n        /* istanbul ignore next */\n        // TODO: Either fix this lint violation or explain why it's necessary to ignore.\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n      }\n    });\n  }\n\n  /**\n   * Unlock a QR hardware wallet account.\n   *\n   * @param index - The index of the account to unlock.\n   * @returns Promise resolving when the operation completes.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    this.#assertIsUnlocked();\n\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring() || (await this.#addQRKeyring());\n\n      keyring.setAccountToUnlock(index);\n      await keyring.addAccounts(1);\n    });\n  }\n\n  async getAccountKeyringType(account: string): Promise<string> {\n    this.#assertIsUnlocked();\n\n    const keyring = (await this.getKeyringForAccount(account)) as EthKeyring;\n    return keyring.type;\n  }\n\n  /**\n   * Forget the QR hardware wallet.\n   *\n   * @returns Promise resolving to the removed accounts and the remaining accounts.\n   * @deprecated Use `withKeyring` instead.\n   */\n  async forgetQRDevice(): Promise<{\n    removedAccounts: string[];\n    remainingAccounts: string[];\n  }> {\n    this.#assertIsUnlocked();\n\n    return this.#persistOrRollback(async () => {\n      const keyring = this.getQRKeyring();\n\n      if (!keyring) {\n        return { removedAccounts: [], remainingAccounts: [] };\n      }\n\n      const allAccounts = (await this.#getAccountsFromKeyrings()) as string[];\n      keyring.forgetDevice();\n      const remainingAccounts =\n        (await this.#getAccountsFromKeyrings()) as string[];\n      const removedAccounts = allAccounts.filter(\n        (address: string) => !remainingAccounts.includes(address),\n      );\n      return { removedAccounts, remainingAccounts };\n    });\n  }\n\n  /**\n   * Constructor helper for registering this controller's messaging system\n   * actions.\n   */\n  #registerMessageHandlers() {\n    this.messagingSystem.registerActionHandler(\n      `${name}:signMessage`,\n      this.signMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signEip7702Authorization`,\n      this.signEip7702Authorization.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signPersonalMessage`,\n      this.signPersonalMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signTypedMessage`,\n      this.signTypedMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:decryptMessage`,\n      this.decryptMessage.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getEncryptionPublicKey`,\n      this.getEncryptionPublicKey.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getAccounts`,\n      this.getAccounts.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringsByType`,\n      this.getKeyringsByType.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:getKeyringForAccount`,\n      this.getKeyringForAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:persistAllKeyrings`,\n      this.persistAllKeyrings.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:prepareUserOperation`,\n      this.prepareUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:patchUserOperation`,\n      this.patchUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:signUserOperation`,\n      this.signUserOperation.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:addNewAccount`,\n      this.addNewAccount.bind(this),\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${name}:withKeyring`,\n      this.withKeyring.bind(this),\n    );\n  }\n\n  /**\n   * Get the keyring by id.\n   *\n   * @param keyringId - The id of the keyring.\n   * @returns The keyring.\n   */\n  #getKeyringById(keyringId: string): EthKeyring | undefined {\n    return this.#keyrings.find(({ metadata }) => metadata.id === keyringId)\n      ?.keyring;\n  }\n\n  /**\n   * Get the keyring by id or return the first keyring if the id is not found.\n   *\n   * @param keyringId - The id of the keyring.\n   * @returns The keyring.\n   */\n  #getKeyringByIdOrDefault(keyringId?: string): EthKeyring | undefined {\n    if (!keyringId) {\n      return this.#keyrings[0]?.keyring;\n    }\n\n    return this.#getKeyringById(keyringId);\n  }\n\n  /**\n   * Get the metadata for the specified keyring.\n   *\n   * @param keyring - The keyring instance to get the metadata for.\n   * @returns The keyring metadata.\n   */\n  #getKeyringMetadata(keyring: unknown): KeyringMetadata {\n    const keyringWithMetadata = this.#keyrings.find(\n      (candidate) => candidate.keyring === keyring,\n    );\n    if (!keyringWithMetadata) {\n      throw new Error(KeyringControllerError.KeyringNotFound);\n    }\n    return keyringWithMetadata.metadata;\n  }\n\n  /**\n   * Get the keyring builder for the given `type`.\n   *\n   * @param type - The type of keyring to get the builder for.\n   * @returns The keyring builder, or undefined if none exists.\n   */\n  #getKeyringBuilderForType(\n    type: string,\n  ): { (): EthKeyring; type: string } | undefined {\n    return this.#keyringBuilders.find(\n      (keyringBuilder) => keyringBuilder.type === type,\n    );\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   * @throws If a QRKeyring builder is not provided\n   * when initializing the controller\n   */\n  async #addQRKeyring(): Promise<QRKeyring> {\n    this.#assertControllerMutexIsLocked();\n\n    // QRKeyring is not yet compatible with Keyring type from @metamask/utils\n    return (await this.#newKeyring(KeyringTypes.qr)) as unknown as QRKeyring;\n  }\n\n  /**\n   * Subscribe to a QRKeyring state change events and\n   * forward them through the messaging system.\n   *\n   * @param qrKeyring - The QRKeyring instance to subscribe to\n   */\n  #subscribeToQRKeyringEvents(qrKeyring: QRKeyring) {\n    this.#qrKeyringStateListener = (state) => {\n      this.messagingSystem.publish(`${name}:qrKeyringStateChange`, state);\n    };\n\n    qrKeyring.getMemStore().subscribe(this.#qrKeyringStateListener);\n  }\n\n  #unsubscribeFromQRKeyringsEvents() {\n    const qrKeyrings = this.getKeyringsByType(\n      KeyringTypes.qr,\n    ) as unknown as QRKeyring[];\n\n    qrKeyrings.forEach((qrKeyring) => {\n      if (this.#qrKeyringStateListener) {\n        qrKeyring.getMemStore().unsubscribe(this.#qrKeyringStateListener);\n      }\n    });\n  }\n\n  /**\n   * Create new vault with an initial keyring\n   *\n   * Destroys any old encrypted storage,\n   * creates a new encrypted store with the given password,\n   * creates a new wallet with 1 account.\n   *\n   * @fires KeyringController:unlock\n   * @param password - The password to encrypt the vault with.\n   * @param keyring - A object containing the params to instantiate a new keyring.\n   * @param keyring.type - The keyring type.\n   * @param keyring.opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves to the state.\n   */\n  async #createNewVaultWithKeyring(\n    password: string,\n    keyring: {\n      type: string;\n      opts?: unknown;\n    },\n  ): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n\n    if (typeof password !== 'string') {\n      throw new TypeError(KeyringControllerError.WrongPasswordType);\n    }\n\n    this.update((state) => {\n      delete state.encryptionKey;\n      delete state.encryptionSalt;\n    });\n\n    this.#password = password;\n\n    await this.#clearKeyrings();\n    await this.#createKeyringWithFirstAccount(keyring.type, keyring.opts);\n    this.#setUnlocked();\n  }\n\n  /**\n   * Internal non-exclusive method to verify the seed phrase.\n   *\n   * @param keyringId - The id of the keyring to verify the seed phrase for.\n   * @returns A promise resolving to the seed phrase as Uint8Array.\n   */\n  async #verifySeedPhrase(keyringId?: string): Promise<Uint8Array> {\n    this.#assertControllerMutexIsLocked();\n\n    const keyring = this.#getKeyringByIdOrDefault(keyringId);\n\n    if (!keyring) {\n      throw new Error(KeyringControllerError.KeyringNotFound);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    if (keyring.type !== KeyringTypes.hd) {\n      throw new Error(KeyringControllerError.UnsupportedVerifySeedPhrase);\n    }\n\n    assertHasUint8ArrayMnemonic(keyring);\n\n    const seedWords = keyring.mnemonic;\n    const accounts = await keyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    // The HD Keyring Builder is a default keyring builder\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const hdKeyringBuilder = this.#getKeyringBuilderForType(KeyringTypes.hd)!;\n\n    const hdKeyring = hdKeyringBuilder();\n    // @ts-expect-error @metamask/eth-hd-keyring correctly handles\n    // Uint8Array seed phrases in the `deserialize` method.\n    await hdKeyring.deserialize({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await hdKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Get the updated array of each keyring's type and\n   * accounts list.\n   *\n   * @returns A promise resolving to the updated keyrings array.\n   */\n  async #getUpdatedKeyrings(): Promise<KeyringObject[]> {\n    return Promise.all(this.#keyrings.map(displayForKeyring));\n  }\n\n  /**\n   * Serialize the current array of keyring instances,\n   * including unsupported keyrings by default.\n   *\n   * @param options - Method options.\n   * @param options.includeUnsupported - Whether to include unsupported keyrings.\n   * @returns The serialized keyrings.\n   */\n  async #getSerializedKeyrings(\n    { includeUnsupported }: { includeUnsupported: boolean } = {\n      includeUnsupported: true,\n    },\n  ): Promise<SerializedKeyring[]> {\n    const serializedKeyrings: SerializedKeyring[] = await Promise.all(\n      this.#keyrings.map(async ({ keyring, metadata }) => {\n        return {\n          type: keyring.type,\n          data: await keyring.serialize(),\n          metadata,\n        };\n      }),\n    );\n\n    if (includeUnsupported) {\n      serializedKeyrings.push(...this.#unsupportedKeyrings);\n    }\n\n    return serializedKeyrings;\n  }\n\n  /**\n   * Get a snapshot of session data held by class variables.\n   *\n   * @returns An object with serialized keyrings, keyrings metadata,\n   * and the user password.\n   */\n  async #getSessionState(): Promise<SessionState> {\n    return {\n      keyrings: await this.#getSerializedKeyrings(),\n      password: this.#password,\n    };\n  }\n\n  /**\n   * Restore a serialized keyrings array.\n   *\n   * @param serializedKeyrings - The serialized keyrings array.\n   * @returns The restored keyrings.\n   */\n  async #restoreSerializedKeyrings(\n    serializedKeyrings: SerializedKeyring[],\n  ): Promise<{\n    keyrings: { keyring: EthKeyring; metadata: KeyringMetadata }[];\n    newMetadata: boolean;\n  }> {\n    await this.#clearKeyrings();\n    const keyrings: { keyring: EthKeyring; metadata: KeyringMetadata }[] = [];\n    let newMetadata = false;\n\n    for (const serializedKeyring of serializedKeyrings) {\n      const result = await this.#restoreKeyring(serializedKeyring);\n      if (result) {\n        const { keyring, metadata } = result;\n        keyrings.push({ keyring, metadata });\n        if (result.newMetadata) {\n          newMetadata = true;\n        }\n      }\n    }\n\n    return { keyrings, newMetadata };\n  }\n\n  /**\n   * Unlock Keyrings, decrypting the vault and deserializing all\n   * keyrings contained in it, using a password or an encryption key with salt.\n   *\n   * @param password - The keyring controller password.\n   * @param encryptionKey - An exported key string to unlock keyrings with.\n   * @param encryptionSalt - The salt used to encrypt the vault.\n   * @returns A promise resolving to the deserialized keyrings array.\n   */\n  async #unlockKeyrings(\n    password: string | undefined,\n    encryptionKey?: string,\n    encryptionSalt?: string,\n  ): Promise<{\n    keyrings: { keyring: EthKeyring; metadata: KeyringMetadata }[];\n    newMetadata: boolean;\n  }> {\n    return this.#withVaultLock(async () => {\n      const encryptedVault = this.state.vault;\n      if (!encryptedVault) {\n        throw new Error(KeyringControllerError.VaultError);\n      }\n\n      let vault;\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (password) {\n          const result = await this.#encryptor.decryptWithDetail(\n            password,\n            encryptedVault,\n          );\n          vault = result.vault;\n          this.#password = password;\n\n          updatedState.encryptionKey = result.exportedKeyString;\n          updatedState.encryptionSalt = result.salt;\n        } else {\n          const parsedEncryptedVault = JSON.parse(encryptedVault);\n\n          if (encryptionSalt && encryptionSalt !== parsedEncryptedVault.salt) {\n            throw new Error(KeyringControllerError.ExpiredCredentials);\n          } else {\n            encryptionSalt = parsedEncryptedVault.salt as string;\n          }\n\n          if (typeof encryptionKey !== 'string') {\n            throw new TypeError(KeyringControllerError.WrongPasswordType);\n          }\n\n          const key = await this.#encryptor.importKey(encryptionKey);\n          vault = await this.#encryptor.decryptWithKey(\n            key,\n            parsedEncryptedVault,\n          );\n\n          // This call is required on the first call because encryptionKey\n          // is not yet inside the memStore\n          updatedState.encryptionKey = encryptionKey;\n          updatedState.encryptionSalt = encryptionSalt;\n        }\n      } else {\n        if (typeof password !== 'string') {\n          throw new TypeError(KeyringControllerError.WrongPasswordType);\n        }\n\n        vault = await this.#encryptor.decrypt(password, encryptedVault);\n        this.#password = password;\n      }\n\n      if (!isSerializedKeyringsArray(vault)) {\n        throw new Error(KeyringControllerError.VaultDataError);\n      }\n\n      const { keyrings, newMetadata } =\n        await this.#restoreSerializedKeyrings(vault);\n\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n\n      this.update((state) => {\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey || updatedState.encryptionSalt) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = updatedState.encryptionSalt;\n        }\n      });\n\n      return { keyrings, newMetadata };\n    });\n  }\n\n  /**\n   * Update the vault with the current keyrings.\n   *\n   * @returns A promise resolving to `true` if the operation is successful.\n   */\n  #updateVault(): Promise<boolean> {\n    return this.#withVaultLock(async () => {\n      // Ensure no duplicate accounts are persisted.\n      await this.#assertNoDuplicateAccounts();\n\n      const { encryptionKey, encryptionSalt, vault } = this.state;\n      // READ THIS CAREFULLY:\n      // We do check if the vault is still considered up-to-date, if not, we would not re-use the\n      // cached key and we will re-generate a new one (based on the password).\n      //\n      // This helps doing seamless updates of the vault. Useful in case we change some cryptographic\n      // parameters to the KDF.\n      const useCachedKey =\n        encryptionKey && vault && this.#encryptor.isVaultUpdated?.(vault);\n\n      if (!this.#password && !encryptionKey) {\n        throw new Error(KeyringControllerError.MissingCredentials);\n      }\n\n      const serializedKeyrings = await this.#getSerializedKeyrings();\n\n      if (\n        !serializedKeyrings.some((keyring) => keyring.type === KeyringTypes.hd)\n      ) {\n        throw new Error(KeyringControllerError.NoHdKeyring);\n      }\n\n      const updatedState: Partial<KeyringControllerState> = {};\n\n      if (this.#cacheEncryptionKey) {\n        assertIsExportableKeyEncryptor(this.#encryptor);\n\n        if (useCachedKey) {\n          const key = await this.#encryptor.importKey(encryptionKey);\n          const vaultJSON = await this.#encryptor.encryptWithKey(\n            key,\n            serializedKeyrings,\n          );\n          vaultJSON.salt = encryptionSalt;\n          updatedState.vault = JSON.stringify(vaultJSON);\n        } else if (this.#password) {\n          const { vault: newVault, exportedKeyString } =\n            await this.#encryptor.encryptWithDetail(\n              this.#password,\n              serializedKeyrings,\n            );\n\n          updatedState.vault = newVault;\n          updatedState.encryptionKey = exportedKeyString;\n        }\n      } else {\n        assertIsValidPassword(this.#password);\n        updatedState.vault = await this.#encryptor.encrypt(\n          this.#password,\n          serializedKeyrings,\n        );\n      }\n\n      if (!updatedState.vault) {\n        throw new Error(KeyringControllerError.MissingVaultData);\n      }\n\n      const updatedKeyrings = await this.#getUpdatedKeyrings();\n\n      this.update((state) => {\n        state.vault = updatedState.vault;\n        state.keyrings = updatedKeyrings;\n        if (updatedState.encryptionKey) {\n          state.encryptionKey = updatedState.encryptionKey;\n          state.encryptionSalt = JSON.parse(updatedState.vault as string).salt;\n        }\n      });\n\n      return true;\n    });\n  }\n\n  /**\n   * Check if there are new encryption parameters available.\n   *\n   * @returns A promise resolving to `void`.\n   */\n  #isNewEncryptionAvailable(): boolean {\n    const { vault } = this.state;\n\n    if (!vault || !this.#password || !this.#encryptor.isVaultUpdated) {\n      return false;\n    }\n\n    return !this.#encryptor.isVaultUpdated(vault);\n  }\n\n  /**\n   * Retrieves all the accounts from keyrings instances\n   * that are currently in memory.\n   *\n   * @param additionalKeyrings - Additional keyrings to include in the search.\n   * @returns A promise resolving to an array of accounts.\n   */\n  async #getAccountsFromKeyrings(\n    additionalKeyrings: EthKeyring[] = [],\n  ): Promise<string[]> {\n    const keyrings = this.#keyrings.map(({ keyring }) => keyring);\n\n    const keyringArrays = await Promise.all(\n      [...keyrings, ...additionalKeyrings].map(async (keyring) =>\n        keyring.getAccounts(),\n      ),\n    );\n    const addresses = keyringArrays.reduce((res, arr) => {\n      return res.concat(arr);\n    }, []);\n\n    // Cast to `string[]` here is safe here because `addresses` has no nullish\n    // values, and `normalize` returns `string` unless given a nullish value\n    return addresses.map(normalize) as string[];\n  }\n\n  /**\n   * Create a new keyring, ensuring that the first account is\n   * also created.\n   *\n   * @param type - Keyring type to instantiate.\n   * @param opts - Optional parameters required to instantiate the keyring.\n   * @returns A promise that resolves if the operation is successful.\n   */\n  async #createKeyringWithFirstAccount(type: string, opts?: unknown) {\n    this.#assertControllerMutexIsLocked();\n\n    const keyring = (await this.#newKeyring(type, opts)) as EthKeyring;\n\n    const [firstAccount] = await keyring.getAccounts();\n    if (!firstAccount) {\n      throw new Error(KeyringControllerError.NoFirstAccount);\n    }\n    return firstAccount;\n  }\n\n  /**\n   * Instantiate, initialize and return a new keyring of the given `type`,\n   * using the given `opts`. The keyring is built using the keyring builder\n   * registered for the given `type`.\n   *\n   * The internal keyring and keyring metadata arrays are updated with the new\n   * keyring as well.\n   *\n   * @param type - The type of keyring to add.\n   * @param data - Keyring initialization options.\n   * @returns The new keyring.\n   * @throws If the keyring includes duplicated accounts.\n   */\n  async #newKeyring(type: string, data?: unknown): Promise<EthKeyring> {\n    const keyring = await this.#createKeyring(type, data);\n\n    this.#keyrings.push({ keyring, metadata: getDefaultKeyringMetadata() });\n\n    return keyring;\n  }\n\n  /**\n   * Instantiate, initialize and return a keyring of the given `type` using the\n   * given `opts`. The keyring is built using the keyring builder registered\n   * for the given `type`.\n   *\n   * The keyring might be new, or it might be restored from the vault. This\n   * function should only be called from `#newKeyring` or `#restoreKeyring`,\n   * for the \"new\" and \"restore\" cases respectively.\n   *\n   * The internal keyring and keyring metadata arrays are *not* updated, the\n   * caller is expected to update them.\n   *\n   * @param type - The type of keyring to add.\n   * @param data - Keyring initialization options.\n   * @returns The new keyring.\n   * @throws If the keyring includes duplicated accounts.\n   */\n  async #createKeyring(type: string, data?: unknown): Promise<EthKeyring> {\n    this.#assertControllerMutexIsLocked();\n\n    const keyringBuilder = this.#getKeyringBuilderForType(type);\n\n    if (!keyringBuilder) {\n      throw new Error(\n        `${KeyringControllerError.NoKeyringBuilder}. Keyring type: ${type}`,\n      );\n    }\n\n    const keyring = keyringBuilder();\n    if (data) {\n      // @ts-expect-error Enforce data type after updating clients\n      await keyring.deserialize(data);\n    }\n\n    if (keyring.init) {\n      await keyring.init();\n    }\n\n    if (type === KeyringTypes.hd && (!isObject(data) || !data.mnemonic)) {\n      if (!keyring.generateRandomMnemonic) {\n        throw new Error(\n          KeyringControllerError.UnsupportedGenerateRandomMnemonic,\n        );\n      }\n\n      // NOTE: Not all keyrings implement this method in a asynchronous-way. Using `await` for\n      // non-thenable will still be valid (despite not being really useful). It allows us to cover both\n      // cases and allow retro-compatibility too.\n      await keyring.generateRandomMnemonic();\n      await keyring.addAccounts(1);\n    }\n\n    if (type === KeyringTypes.qr) {\n      // In case of a QR keyring type, we need to subscribe\n      // to its events after creating it\n      this.#subscribeToQRKeyringEvents(keyring as unknown as QRKeyring);\n    }\n\n    return keyring;\n  }\n\n  /**\n   * Remove all managed keyrings, destroying all their\n   * instances in memory.\n   */\n  async #clearKeyrings() {\n    this.#assertControllerMutexIsLocked();\n    for (const { keyring } of this.#keyrings) {\n      await this.#destroyKeyring(keyring);\n    }\n    this.#keyrings = [];\n    this.#unsupportedKeyrings = [];\n  }\n\n  /**\n   * Restore a Keyring from a provided serialized payload.\n   * On success, returns the resulting keyring instance.\n   *\n   * @param serialized - The serialized keyring.\n   * @returns The deserialized keyring or undefined if the keyring type is unsupported.\n   */\n  async #restoreKeyring(\n    serialized: SerializedKeyring,\n  ): Promise<\n    | { keyring: EthKeyring; metadata: KeyringMetadata; newMetadata: boolean }\n    | undefined\n  > {\n    this.#assertControllerMutexIsLocked();\n\n    try {\n      const { type, data, metadata: serializedMetadata } = serialized;\n      let newMetadata = false;\n      let metadata = serializedMetadata;\n      const keyring = await this.#createKeyring(type, data);\n      await this.#assertNoDuplicateAccounts([keyring]);\n      // If metadata is missing, assume the data is from an installation before\n      // we had keyring metadata.\n      if (!metadata) {\n        newMetadata = true;\n        metadata = getDefaultKeyringMetadata();\n      }\n      // The keyring is added to the keyrings array only if it's successfully restored\n      // and the metadata is successfully added to the controller\n      this.#keyrings.push({\n        keyring,\n        metadata,\n      });\n      return { keyring, metadata, newMetadata };\n    } catch (error) {\n      console.error(error);\n      this.#unsupportedKeyrings.push(serialized);\n      return undefined;\n    }\n  }\n\n  /**\n   * Destroy Keyring\n   *\n   * Some keyrings support a method called `destroy`, that destroys the\n   * keyring along with removing all its event listeners and, in some cases,\n   * clears the keyring bridge iframe from the DOM.\n   *\n   * @param keyring - The keyring to destroy.\n   */\n  async #destroyKeyring(keyring: EthKeyring) {\n    await keyring.destroy?.();\n  }\n\n  /**\n   * Remove empty keyrings.\n   *\n   * Loops through the keyrings and removes the ones with empty accounts\n   * (usually after removing the last / only account) from a keyring.\n   */\n  async #removeEmptyKeyrings(): Promise<void> {\n    this.#assertControllerMutexIsLocked();\n    const validKeyrings: { keyring: EthKeyring; metadata: KeyringMetadata }[] =\n      [];\n\n    // Since getAccounts returns a Promise\n    // We need to wait to hear back form each keyring\n    // in order to decide which ones are now valid (accounts.length > 0)\n\n    await Promise.all(\n      this.#keyrings.map(async ({ keyring, metadata }) => {\n        const accounts = await keyring.getAccounts();\n        if (accounts.length > 0) {\n          validKeyrings.push({ keyring, metadata });\n        } else {\n          await this.#destroyKeyring(keyring);\n        }\n      }),\n    );\n    this.#keyrings = validKeyrings;\n  }\n\n  /**\n   * Assert that there are no duplicate accounts in the keyrings.\n   *\n   * @param additionalKeyrings - Additional keyrings to include in the check.\n   * @throws If there are duplicate accounts.\n   */\n  async #assertNoDuplicateAccounts(\n    additionalKeyrings: EthKeyring[] = [],\n  ): Promise<void> {\n    const accounts = await this.#getAccountsFromKeyrings(additionalKeyrings);\n\n    if (new Set(accounts).size !== accounts.length) {\n      throw new Error(KeyringControllerError.DuplicatedAccount);\n    }\n  }\n\n  /**\n   * Set the `isUnlocked` to true and notify listeners\n   * through the messenger.\n   *\n   * @fires KeyringController:unlock\n   */\n  #setUnlocked(): void {\n    this.#assertControllerMutexIsLocked();\n\n    this.update((state) => {\n      state.isUnlocked = true;\n    });\n    this.messagingSystem.publish(`${name}:unlock`);\n  }\n\n  /**\n   * Assert that the controller is unlocked.\n   *\n   * @throws If the controller is locked.\n   */\n  #assertIsUnlocked(): void {\n    if (!this.state.isUnlocked) {\n      throw new Error(KeyringControllerError.ControllerLocked);\n    }\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and save the vault to state after it (only if needed), or rollback to their\n   * previous state in case of error.\n   *\n   * @param callback - The function to execute.\n   * @returns The result of the function.\n   */\n  async #persistOrRollback<Result>(\n    callback: MutuallyExclusiveCallback<Result>,\n  ): Promise<Result> {\n    return this.#withRollback(async ({ releaseLock }) => {\n      const oldState = JSON.stringify(await this.#getSessionState());\n      const callbackResult = await callback({ releaseLock });\n      const newState = JSON.stringify(await this.#getSessionState());\n\n      // State is committed only if the operation is successful and need to trigger a vault update.\n      if (!isEqual(oldState, newState)) {\n        await this.#updateVault();\n      }\n\n      return callbackResult;\n    });\n  }\n\n  /**\n   * Execute the given function after acquiring the controller lock\n   * and rollback keyrings and password states in case of error.\n   *\n   * @param callback - The function to execute atomically.\n   * @returns The result of the function.\n   */\n  async #withRollback<Result>(\n    callback: MutuallyExclusiveCallback<Result>,\n  ): Promise<Result> {\n    return this.#withControllerLock(async ({ releaseLock }) => {\n      const currentSerializedKeyrings = await this.#getSerializedKeyrings();\n      const currentPassword = this.#password;\n\n      try {\n        return await callback({ releaseLock });\n      } catch (e) {\n        // Keyrings and password are restored to their previous state\n        this.#password = currentPassword;\n        await this.#restoreSerializedKeyrings(currentSerializedKeyrings);\n\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Assert that the controller mutex is locked.\n   *\n   * @throws If the controller mutex is not locked.\n   */\n  #assertControllerMutexIsLocked() {\n    if (!this.#controllerOperationMutex.isLocked()) {\n      throw new Error(KeyringControllerError.ControllerLockRequired);\n    }\n  }\n\n  /**\n   * Lock the controller mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This wrapper ensures that each mutable operation that interacts with the\n   * controller and that changes its state is executed in a mutually exclusive way,\n   * preventing unsafe concurrent access that could lead to unpredictable behavior.\n   *\n   * @param callback - The function to execute while the controller mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withControllerLock<Result>(\n    callback: MutuallyExclusiveCallback<Result>,\n  ): Promise<Result> {\n    return withLock(this.#controllerOperationMutex, callback);\n  }\n\n  /**\n   * Lock the vault mutex before executing the given function,\n   * and release it after the function is resolved or after an\n   * error is thrown.\n   *\n   * This ensures that each operation that interacts with the vault\n   * is executed in a mutually exclusive way.\n   *\n   * @param callback - The function to execute while the vault mutex is locked.\n   * @returns The result of the function.\n   */\n  async #withVaultLock<Result>(\n    callback: MutuallyExclusiveCallback<Result>,\n  ): Promise<Result> {\n    this.#assertControllerMutexIsLocked();\n\n    return withLock(this.#vaultOperationMutex, callback);\n  }\n}\n\n/**\n * Lock the given mutex before executing the given function,\n * and release it after the function is resolved or after an\n * error is thrown.\n *\n * @param mutex - The mutex to lock.\n * @param callback - The function to execute while the mutex is locked.\n * @returns The result of the function.\n */\nasync function withLock<Result>(\n  mutex: Mutex,\n  callback: MutuallyExclusiveCallback<Result>,\n): Promise<Result> {\n  const releaseLock = await mutex.acquire();\n\n  try {\n    return await callback({ releaseLock });\n  } finally {\n    releaseLock();\n  }\n}\n\n/**\n * Generate a new keyring metadata object.\n *\n * @returns Keyring metadata.\n */\nfunction getDefaultKeyringMetadata(): KeyringMetadata {\n  return { id: ulid(), name: '' };\n}\n\nexport default KeyringController;\n"]}